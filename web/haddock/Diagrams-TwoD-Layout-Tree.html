<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Diagrams.TwoD.Layout.Tree</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Diagrams-TwoD-Layout-Tree.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Diagrams-TwoD-Layout-Tree.html">Source</a></li><li><a href="http://www.haskell.org/haskellwiki/Diagrams/Comments/Diagrams.TwoD.Layout.Tree">User Comments</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">diagrams-contrib-1.0: Collection of user contributions to diagrams EDSL</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Maintainer</th><td>byorgey@cis.upenn.edu</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Diagrams.TwoD.Layout.Tree</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Binary trees
</a></li><li><a href="#g:2">Layout algorithms
</a><ul><li><a href="#g:3">Unique-x layout
</a></li><li><a href="#g:4">Symmetric layout
</a></li><li><a href="#g:5">Force-directed layout
</a></li></ul></li><li><a href="#g:6">Rendering
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A collection of methods for laying out various kinds of trees.
 This module is still experimental, and more layout methods will
 probably be added over time.
</p><p>Laying out a rose tree using a symmetric layout:
</p><pre> import Data.Tree
 import Diagrams.TwoD.Layout.Tree

 t1 = Node 'A' [Node 'B' (map lf &quot;CDE&quot;), Node 'F' [Node 'G' (map lf &quot;HIJ&quot;)]]
   where lf x = Node x []

 exampleSymmTree =
   renderTree ((&lt;&gt; circle 1 # fc white) . text . (:[]))
              (~~)
              (symmLayout' with { slHSep = 4, slVSep = 4 } t1)
   # lw 0.03
   # centerXY # pad 1.1
</pre><p><img src="diagrams/src_Diagrams_TwoD_Layout_Tree_exampleSymmTree.svg#diagram=exampleSymmTree&amp;width=300" />
</p><p>Laying out a rose tree of diagrams, with spacing automatically
 adjusted for the size of the diagrams:
</p><pre> import Data.Tree
 import Data.Maybe (fromMaybe)
 import Diagrams.TwoD.Layout.Tree

 tD = Node (rect 1 3)
        [ Node (circle 0.2) []
        , Node (hcat . replicate 3 $ circle 1) []
        , Node (eqTriangle 5) []
        ]

 exampleSymmTreeWithDs =
   renderTree id (~~)
   (symmLayout' with { slWidth  = fromMaybe (0,0) . extentX
                     , slHeight = fromMaybe (0,0) . extentY }
      tD)
   # lw 0.03
   # centerXY # pad 1.1
</pre><p><img src="diagrams/src_Diagrams_TwoD_Layout_Tree_exampleSymmTreeWithDs.svg#diagram=exampleSymmTreeWithDs&amp;width=300" />
</p><p>Using a variant symmetric layout algorithm specifically for binary trees:
</p><pre> import Diagrams.TwoD.Layout.Tree

 drawT = maybe mempty (renderTree (const (circle 0.05 # fc black)) (~~))
       . symmLayoutBin' with { slVSep = 0.5 }

 tree500 = drawT t # centerXY # pad 1.1 # sized (Width 4)
   where t = genTree 500 0.05
         -- genTree 500 0.05 randomly generates trees of size 500 +/- 5%,
         -- definition not shown
</pre><p><img src="diagrams/src_Diagrams_TwoD_Layout_Tree_tree500.svg#diagram=tree500&amp;width=400" />
</p><p>Using force-based layout on a binary tree:
</p><pre> {-# LANGUAGE NoMonomorphismRestriction #-}
 import Diagrams.Prelude
 import Diagrams.TwoD.Layout.Tree

 t 0 = Empty
 t n = BNode n (t (n-1)) (t (n-1))

 Just t' = uniqueXLayout 1 1 (t 4)

 fblEx = renderTree (\n -&gt; (text (show n) # fontSize 0.5
                             &lt;&gt; circle 0.3 # fc white))
             (~~)
             (forceLayoutTree t')
         # centerXY # pad 1.1
</pre><p><img src="diagrams/src_Diagrams_TwoD_Layout_Tree_fblEx.svg#diagram=fblEx&amp;width=300" />
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:BTree">BTree</a> a<ul class="subs"><li>= <a href="#v:Empty">Empty</a>  </li><li>| <a href="#v:BNode">BNode</a> a (<a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a) (<a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a)  </li></ul></li><li class="src short"><a href="#v:leaf">leaf</a> ::  a -&gt; <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a</li><li class="src short"><a href="#v:uniqueXLayout">uniqueXLayout</a> ::  <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>))</li><li class="src short"><a href="#v:symmLayout">symmLayout</a> ::  <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>)</li><li class="src short"><a href="#v:symmLayout-39-">symmLayout'</a> ::  <a href="Diagrams-TwoD-Layout-Tree.html#t:SymmLayoutOpts">SymmLayoutOpts</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>)</li><li class="src short"><a href="#v:symmLayoutBin">symmLayoutBin</a> ::  <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>))</li><li class="src short"><a href="#v:symmLayoutBin-39-">symmLayoutBin'</a> ::  <a href="Diagrams-TwoD-Layout-Tree.html#t:SymmLayoutOpts">SymmLayoutOpts</a> a -&gt; <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>))</li><li class="src short"><span class="keyword">data</span>  <a href="#t:SymmLayoutOpts">SymmLayoutOpts</a> a = <a href="#v:SLOpts">SLOpts</a> {<ul class="subs"><li><a href="#v:slHSep">slHSep</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:slVSep">slVSep</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:slWidth">slWidth</a> :: a -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a>)</li><li><a href="#v:slHeight">slHeight</a> :: a -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a>)</li></ul>}</li><li class="src short"><a href="#v:forceLayoutTree">forceLayoutTree</a> ::  <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>)</li><li class="src short"><a href="#v:forceLayoutTree-39-">forceLayoutTree'</a> ::  <a href="Diagrams-TwoD-Layout-Tree.html#t:ForceLayoutTreeOpts">ForceLayoutTreeOpts</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:ForceLayoutTreeOpts">ForceLayoutTreeOpts</a>  = <a href="#v:FLTOpts">FLTOpts</a> {<ul class="subs"><li><a href="#v:forceLayoutOpts">forceLayoutOpts</a> :: <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:ForceLayoutOpts">ForceLayoutOpts</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a></li><li><a href="#v:edgeLen">edgeLen</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:springK">springK</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:staticK">staticK</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></li></ul>}</li><li class="src short"><a href="#v:treeToEnsemble">treeToEnsemble</a> :: <span class="keyword">forall</span> a.  <a href="Diagrams-TwoD-Layout-Tree.html#t:ForceLayoutTreeOpts">ForceLayoutTreeOpts</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:PID">PID</a>), <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:Ensemble">Ensemble</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a>)</li><li class="src short"><a href="#v:label">label</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Traversable.html#t:Traversable">Traversable</a> t =&gt; t a -&gt; t (a, <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:PID">PID</a>)</li><li class="src short"><a href="#v:reconstruct">reconstruct</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> t =&gt; <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:Ensemble">Ensemble</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> -&gt; t (a, <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:PID">PID</a>) -&gt; t (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>)</li><li class="src short"><a href="#v:renderTree">renderTree</a> :: <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m =&gt; (a -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m) -&gt; (<a href="Diagrams-TwoD-Types.html#t:P2">P2</a> -&gt; <a href="Diagrams-TwoD-Types.html#t:P2">P2</a> -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m) -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m</li><li class="src short"><a href="#v:renderTree-39-">renderTree'</a> :: <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m =&gt; (a -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m) -&gt; ((a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m) -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m</li></ul></div><div id="interface"><h1 id="g:1">Binary trees
</h1><div class="doc"><p>There is a standard type of rose trees (<code><a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a></code>) defined in the
 <code>containers</code> package, but there is no standard type for binary
 trees, so we define one here.  Note, if you want to draw binary
 trees with data of type <code>a</code> at the leaves, you can use something
 like <code>BTree (Maybe a)</code> with <code>Nothing</code> at internal nodes;
 <code><a href="Diagrams-TwoD-Layout-Tree.html#v:renderTree">renderTree</a></code> lets you specify how to draw each node.
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:BTree" class="def">BTree</a> a <a href="src/Diagrams-TwoD-Layout-Tree.html#BTree" class="link">Source</a></p><div class="doc"><p>Binary trees with data at internal nodes.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Empty" class="def">Empty</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:BNode" class="def">BNode</a> a (<a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a) (<a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:BTree" class="caption collapser" onclick="toggleSection('i:BTree')">Instances</p><div id="section.i:BTree" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Foldable.html#t:Foldable">Foldable</a> <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Traversable.html#t:Traversable">Traversable</a> <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Read.html#t:Read">Read</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Read.html#t:Read">Read</a> (<a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:leaf" class="def">leaf</a> ::  a -&gt; <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a<a href="src/Diagrams-TwoD-Layout-Tree.html#leaf" class="link">Source</a></p><div class="doc"><p>Convenient constructor for leaves.
</p></div></div><h1 id="g:2">Layout algorithms
</h1><h2 id="g:3">Unique-x layout
</h2><div class="top"><p class="src"><a name="v:uniqueXLayout" class="def">uniqueXLayout</a> ::  <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>))<a href="src/Diagrams-TwoD-Layout-Tree.html#uniqueXLayout" class="link">Source</a></p><div class="doc"><p><code>uniqueXLayout xSep ySep t</code> lays out the binary tree <code>t</code> using a
   simple recursive algorithm with the following properties:
</p><ul><li> Every left subtree is completely to the left of its parent, and
     similarly for right subtrees.
</li><li> All the nodes at a given depth in the tree have the same
     y-coordinate. The separation distance between levels is given by
     <code>ySep</code>.
</li><li> Every node has a unique x-coordinate. The separation between
     successive nodes from left to right is given by <code>xSep</code>.
</li></ul></div></div><h2 id="g:4">Symmetric layout
</h2><div class="doc"><p>&quot;Symmetric&quot; layout of rose trees, based on the algorithm described in:
</p><p>Andrew J. Kennedy. <em>Drawing Trees</em>, J Func. Prog. 6 (3): 527-534,
 May 1996.
</p><p>Trees laid out using this algorithm satisfy:
</p><ol><li> Nodes at a given level are always separated by at least a
   given minimum distance.
</li><li> Parent nodes are centered with respect to their immediate
   offspring (though <em>not</em> necessarily with respect to the entire
   subtrees under them).
</li><li> Layout commutes with mirroring: that is, the layout of a given
   tree is the mirror image of the layout of the tree's mirror
   image.  Put another way, there is no inherent left or right bias.
</li><li> Identical subtrees are always rendered identically.  Put
   another way, the layout of any subtree is independent of the rest
   of the tree.
</li><li> The layouts are as narrow as possible while satisfying all the
   above constraints.
</li></ol></div><div class="top"><p class="src"><a name="v:symmLayout" class="def">symmLayout</a> ::  <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>)<a href="src/Diagrams-TwoD-Layout-Tree.html#symmLayout" class="link">Source</a></p><div class="doc"><p>Run the symmetric rose tree layout algorithm on a given tree
   using default options, resulting in the same tree annotated with
   node positions.
</p></div></div><div class="top"><p class="src"><a name="v:symmLayout-39-" class="def">symmLayout'</a> ::  <a href="Diagrams-TwoD-Layout-Tree.html#t:SymmLayoutOpts">SymmLayoutOpts</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>)<a href="src/Diagrams-TwoD-Layout-Tree.html#symmLayout%27" class="link">Source</a></p><div class="doc"><p>Run the symmetric rose tree layout algorithm on a given tree,
   resulting in the same tree annotated with node positions.
</p></div></div><div class="top"><p class="src"><a name="v:symmLayoutBin" class="def">symmLayoutBin</a> ::  <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>))<a href="src/Diagrams-TwoD-Layout-Tree.html#symmLayoutBin" class="link">Source</a></p><div class="doc"><p>Lay out a binary tree using a slight variant of the symmetric
   layout algorithm, using default options.  In particular, if a
   node has only a left child but no right child (or vice versa),
   the child will be offset from the parent horizontally by half the
   horizontal separation parameter. Note that the result will be
   <code>Nothing</code> if and only if the input tree is <code>Empty</code>.
</p></div></div><div class="top"><p class="src"><a name="v:symmLayoutBin-39-" class="def">symmLayoutBin'</a> ::  <a href="Diagrams-TwoD-Layout-Tree.html#t:SymmLayoutOpts">SymmLayoutOpts</a> a -&gt; <a href="Diagrams-TwoD-Layout-Tree.html#t:BTree">BTree</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>))<a href="src/Diagrams-TwoD-Layout-Tree.html#symmLayoutBin%27" class="link">Source</a></p><div class="doc"><p>Lay out a binary tree using a slight variant of the symmetric
   layout algorithm.  In particular, if a node has only a left child
   but no right child (or vice versa), the child will be offset from
   the parent horizontally by half the horizontal separation
   parameter. Note that the result will be <code>Nothing</code> if and only if
   the input tree is <code>Empty</code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:SymmLayoutOpts" class="def">SymmLayoutOpts</a> a <a href="src/Diagrams-TwoD-Layout-Tree.html#SymmLayoutOpts" class="link">Source</a></p><div class="doc"><p>Options for controlling the symmetric tree layout algorithm.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:SLOpts" class="def">SLOpts</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:slHSep" class="def">slHSep</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Minimum horizontal
   separation between sibling
   nodes.  The default is 1.
</p></dd><dt class="src"><a name="v:slVSep" class="def">slVSep</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Vertical separation
   between adjacent levels of
   the tree.  The default is 1.
</p></dd><dt class="src"><a name="v:slWidth" class="def">slWidth</a> :: a -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a>)</dt><dd class="doc"><p>A function for measuring the horizontal extent (a pair
   of x-coordinates) of an item in the tree.  The default
   is <code>const (0,0)</code>, that is, the nodes are considered as
   taking up no space, so the centers of the nodes will
   be separated according to the <code>slHSep</code> and <code>slVSep</code>.
   However, this can be useful, <em>e.g.</em> if you have a tree
   of diagrams of irregular size and want to make sure no
   diagrams overlap.  In that case you could use
   <code>fromMaybe (0,0) . extentX</code>.
</p></dd><dt class="src"><a name="v:slHeight" class="def">slHeight</a> :: a -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a>)</dt><dd class="doc"><p>A function for measuring the vertical extent of an
   item in the tree.  The default is <code>const (0,0)</code>.  See
   the documentation for <code><a href="Diagrams-TwoD-Layout-Tree.html#v:slWidth">slWidth</a></code> for more information.
</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:SymmLayoutOpts" class="caption collapser" onclick="toggleSection('i:SymmLayoutOpts')">Instances</p><div id="section.i:SymmLayoutOpts" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/data-default/0.5.3/doc/html/Data-Default.html#t:Default">Default</a> (<a href="Diagrams-TwoD-Layout-Tree.html#t:SymmLayoutOpts">SymmLayoutOpts</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:5">Force-directed layout
</h2><div class="doc"><p>Force-directed layout of rose trees.
</p></div><div class="top"><p class="src"><a name="v:forceLayoutTree" class="def">forceLayoutTree</a> ::  <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>)<a href="src/Diagrams-TwoD-Layout-Tree.html#forceLayoutTree" class="link">Source</a></p><div class="doc"><p>Force-directed layout of rose trees, with default parameters (for
   more options, see <code><a href="Diagrams-TwoD-Layout-Tree.html#v:forceLayoutTree-39-">forceLayoutTree'</a></code>).  In particular,
</p><ul><li> edges are modeled as springs
</li><li> nodes are modeled as point charges
</li><li> nodes are constrained to keep the same y-coordinate.
</li></ul><p>The input could be a tree already laid out by some other method,
   such as <code><a href="Diagrams-TwoD-Layout-Tree.html#v:uniqueXLayout">uniqueXLayout</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:forceLayoutTree-39-" class="def">forceLayoutTree'</a> ::  <a href="Diagrams-TwoD-Layout-Tree.html#t:ForceLayoutTreeOpts">ForceLayoutTreeOpts</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>)<a href="src/Diagrams-TwoD-Layout-Tree.html#forceLayoutTree%27" class="link">Source</a></p><div class="doc"><p>Force-directed layout of rose trees, with configurable parameters.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ForceLayoutTreeOpts" class="def">ForceLayoutTreeOpts</a>  <a href="src/Diagrams-TwoD-Layout-Tree.html#ForceLayoutTreeOpts" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:FLTOpts" class="def">FLTOpts</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:forceLayoutOpts" class="def">forceLayoutOpts</a> :: <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:ForceLayoutOpts">ForceLayoutOpts</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a></dt><dd class="doc"><p>Options to the force layout simulator, including damping.
</p></dd><dt class="src"><a name="v:edgeLen" class="def">edgeLen</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>How long edges should be, ideally.
   This will be the resting length for
   the springs.
</p></dd><dt class="src"><a name="v:springK" class="def">springK</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Spring constant.  The
   bigger the constant,
   the more the edges
   push/pull towards their
   resting length.
</p></dd><dt class="src"><a name="v:staticK" class="def">staticK</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Coulomb constant.  The
   bigger the constant, the
   more sibling nodes repel
   each other.
</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:ForceLayoutTreeOpts" class="caption collapser" onclick="toggleSection('i:ForceLayoutTreeOpts')">Instances</p><div id="section.i:ForceLayoutTreeOpts" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/data-default/0.5.3/doc/html/Data-Default.html#t:Default">Default</a> <a href="Diagrams-TwoD-Layout-Tree.html#t:ForceLayoutTreeOpts">ForceLayoutTreeOpts</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:treeToEnsemble" class="def">treeToEnsemble</a> :: <span class="keyword">forall</span> a.  <a href="Diagrams-TwoD-Layout-Tree.html#t:ForceLayoutTreeOpts">ForceLayoutTreeOpts</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:PID">PID</a>), <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:Ensemble">Ensemble</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a>)<a href="src/Diagrams-TwoD-Layout-Tree.html#treeToEnsemble" class="link">Source</a></p><div class="doc"><p>Assign unique ID numbers to the nodes of a tree, and generate an
   <code><a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:Ensemble">Ensemble</a></code> suitable for simulating in order to do force-directed
   layout of the tree.  In particular,
</p><ul><li> edges are modeled as springs
</li><li> nodes are modeled as point charges
</li><li> nodes are constrained to keep the same y-coordinate.
</li></ul><p>The input to <code>treeToEnsemble</code> could be a tree already laid out by
   some other method, such as <code><a href="Diagrams-TwoD-Layout-Tree.html#v:uniqueXLayout">uniqueXLayout</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:label" class="def">label</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Traversable.html#t:Traversable">Traversable</a> t =&gt; t a -&gt; t (a, <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:PID">PID</a>)<a href="src/Diagrams-TwoD-Layout-Tree.html#label" class="link">Source</a></p><div class="doc"><p>Assign unique IDs to every node in a tree (or other traversable structure).
</p></div></div><div class="top"><p class="src"><a name="v:reconstruct" class="def">reconstruct</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> t =&gt; <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:Ensemble">Ensemble</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> -&gt; t (a, <a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:PID">PID</a>) -&gt; t (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>)<a href="src/Diagrams-TwoD-Layout-Tree.html#reconstruct" class="link">Source</a></p><div class="doc"><p>Reconstruct a tree (or any traversable structure) from an
   <code><a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:Ensemble">Ensemble</a></code>, given unique identifier annotations matching the
   identifiers used in the <code><a href="http://hackage.haskell.org/packages/archive/force-layout/0.2/doc/html/Physics-ForceLayout.html#t:Ensemble">Ensemble</a></code>.
</p></div></div><h1 id="g:6">Rendering
</h1><div class="top"><p class="src"><a name="v:renderTree" class="def">renderTree</a> :: <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m =&gt; (a -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m) -&gt; (<a href="Diagrams-TwoD-Types.html#t:P2">P2</a> -&gt; <a href="Diagrams-TwoD-Types.html#t:P2">P2</a> -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m) -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m<a href="src/Diagrams-TwoD-Layout-Tree.html#renderTree" class="link">Source</a></p><div class="doc"><p>Draw a tree annotated with node positions, given functions
   specifying how to draw nodes and edges.
</p></div></div><div class="top"><p class="src"><a name="v:renderTree-39-" class="def">renderTree'</a> :: <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m =&gt; (a -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m) -&gt; ((a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m) -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (a, <a href="Diagrams-TwoD-Types.html#t:P2">P2</a>) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> m<a href="src/Diagrams-TwoD-Layout-Tree.html#renderTree%27" class="link">Source</a></p><div class="doc"><p>Draw a tree annotated with node positions, given functions
   specifying how to draw nodes and edges.  Unlike <code><a href="Diagrams-TwoD-Layout-Tree.html#v:renderTree">renderTree</a></code>,
   this version gives the edge-drawing function access to the actual
   values stored at the nodes rather than just their positions.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2.1</p></div></body></html>