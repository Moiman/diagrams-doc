<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Diagrams.Core.Types</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Diagrams-Core-Types.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Diagrams-Core-Types.html">Source</a></li><li><a href="http://www.haskell.org/haskellwiki/Diagrams/Comments/Diagrams.Core.Types">User Comments</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">diagrams-core-1.0: Core libraries for diagrams EDSL</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Maintainer</th><td>diagrams-discuss@googlegroups.com</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Diagrams.Core.Types</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Diagrams
</a><ul><li><a href="#g:2">Annotations
</a></li><li><a href="#g:3">Basic type definitions
</a></li></ul></li><li><a href="#g:4">Operations on diagrams
</a><ul><li><a href="#g:5">Creating diagrams
</a></li><li><a href="#g:6">Extracting information
</a></li><li><a href="#g:7">Combining diagrams
</a></li><li><a href="#g:8">Modifying diagrams
</a><ul><li><a href="#g:9">Names
</a></li><li><a href="#g:10">Other
</a></li></ul></li></ul></li><li><a href="#g:11">Subdiagrams
</a></li><li><a href="#g:12">Subdiagram maps
</a></li><li><a href="#g:13">Primtives
</a></li><li><a href="#g:14">Backends
</a><ul><li><a href="#g:15">Null backend
</a></li></ul></li><li><a href="#g:16">Renderable
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The core library of primitives forming the basis of an embedded
 domain-specific language for describing and rendering diagrams.
</p><p><a href="Diagrams-Core-Types.html">Diagrams.Core.Types</a> defines types and classes for
 primitives, diagrams, and backends.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:UpAnnots">UpAnnots</a> b v m = <a href="Data-Monoid-Deletable.html#t:Deletable">Deletable</a> (<a href="Diagrams-Core-Envelope.html#t:Envelope">Envelope</a> v) <a href="Data-Monoid-MList.html#t::::">:::</a> (<a href="Data-Monoid-Deletable.html#t:Deletable">Deletable</a> (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v) <a href="Data-Monoid-MList.html#t::::">:::</a> (<a href="Data-Monoid-Deletable.html#t:Deletable">Deletable</a> (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m) <a href="Data-Monoid-MList.html#t::::">:::</a> (<a href="Diagrams-Core-Query.html#t:Query">Query</a> v m <a href="Data-Monoid-MList.html#t::::">:::</a> ())))</li><li class="src short"><span class="keyword">type</span> <a href="#t:DownAnnots">DownAnnots</a> v = (<a href="Data-Monoid-Split.html#t:Split">Split</a> (<a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v) <a href="Data-Monoid-Coproduct.html#t::-43-:">:+:</a> <a href="Diagrams-Core-Style.html#t:Style">Style</a> v) <a href="Data-Monoid-MList.html#t::::">:::</a> (<a href="Diagrams-Core-Names.html#t:Name">Name</a> <a href="Data-Monoid-MList.html#t::::">:::</a> ())</li><li class="src short"><a href="#v:transfToAnnot">transfToAnnot</a> ::  <a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v -&gt; <a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v</li><li class="src short"><a href="#v:transfFromAnnot">transfFromAnnot</a> :: <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v -&gt; <a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v</li><li class="src short"><span class="keyword">data</span>  <a href="#t:QDiaLeaf">QDiaLeaf</a> b v m<ul class="subs"><li>= <a href="#v:PrimLeaf">PrimLeaf</a> (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v)  </li><li>| <a href="#v:DelayedLeaf">DelayedLeaf</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)  </li></ul></li><li class="src short"><a href="#v:withQDiaLeaf">withQDiaLeaf</a> ::  (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v -&gt; r) -&gt; ((<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) -&gt; r) -&gt; <a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b v m -&gt; r</li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:QDiagram">QDiagram</a> b v m = <a href="#v:QD">QD</a> (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b v m))</li><li class="src short"><span class="keyword">type</span> <a href="#t:Diagram">Diagram</a> b v = <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a></li><li class="src short"><a href="#v:mkQD">mkQD</a> ::  <a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v -&gt; <a href="Diagrams-Core-Envelope.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m -&gt; <a href="Diagrams-Core-Query.html#t:Query">Query</a> v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:mkQD-39-">mkQD'</a> ::  <a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b v m -&gt; <a href="Diagrams-Core-Envelope.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m -&gt; <a href="Diagrams-Core-Query.html#t:Query">Query</a> v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:pointDiagram">pointDiagram</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v) =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:prims">prims</a> :: <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; [(<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v, (<a href="Data-Monoid-Split.html#t:Split">Split</a> (<a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v), <a href="Diagrams-Core-Style.html#t:Style">Style</a> v))]</li><li class="src short"><a href="#v:envelope">envelope</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Type.html#t:Lens-39-">Lens'</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Envelope.html#t:Envelope">Envelope</a> v)</li><li class="src short"><a href="#v:trace">trace</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Type.html#t:Lens-39-">Lens'</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v)</li><li class="src short"><a href="#v:subMap">subMap</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Type.html#t:Lens-39-">Lens'</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m)</li><li class="src short"><a href="#v:names">names</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; [(<a href="Diagrams-Core-Names.html#t:Name">Name</a>, [<a href="Diagrams-Core-Points.html#t:Point">Point</a> v])]</li><li class="src short"><a href="#v:query">query</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Query.html#t:Query">Query</a> v m</li><li class="src short"><a href="#v:sample">sample</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; m</li><li class="src short"><a href="#v:value">value</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a> -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:resetValue">resetValue</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a></li><li class="src short"><a href="#v:clearValue">clearValue</a> ::  <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a></li><li class="src short"><a href="#v:atop">atop</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:nameSub">nameSub</a> :: (<a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m) -&gt; n -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:lookupName">lookupName</a> :: (<a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; n -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m)</li><li class="src short"><a href="#v:withName">withName</a> :: (<a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; n -&gt; (<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:withNameAll">withNameAll</a> :: (<a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; n -&gt; ([<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m] -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:withNames">withNames</a> :: (<a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; [n] -&gt; ([<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m] -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:localize">localize</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:freeze">freeze</a> :: <span class="keyword">forall</span> v b m. (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:setEnvelope">setEnvelope</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; <a href="Diagrams-Core-Envelope.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:setTrace">setTrace</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Subdiagram">Subdiagram</a> b v m = <a href="#v:Subdiagram">Subdiagram</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v)</li><li class="src short"><a href="#v:mkSubdiagram">mkSubdiagram</a> ::  <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m</li><li class="src short"><a href="#v:getSub">getSub</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:rawSub">rawSub</a> ::  <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:location">location</a> :: <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> v</li><li class="src short"><a href="#v:subPoint">subPoint</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m</li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:SubMap">SubMap</a> b v m = <a href="#v:SubMap">SubMap</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core-Names.html#t:Name">Name</a> [<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m])</li><li class="src short"><a href="#v:fromNames">fromNames</a> :: <a href="Diagrams-Core-Names.html#t:IsName">IsName</a> a =&gt; [(a, <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m)] -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m</li><li class="src short"><a href="#v:rememberAs">rememberAs</a> :: <a href="Diagrams-Core-Names.html#t:IsName">IsName</a> a =&gt; a -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m</li><li class="src short"><a href="#v:lookupSub">lookupSub</a> :: <a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n =&gt; n -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> [<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m]</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Prim">Prim</a> b v <span class="keyword">where</span><ul class="subs"><li><a href="#v:Prim">Prim</a> :: (<a href="Diagrams-Core-Types.html#t:IsPrim">IsPrim</a> p, <a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> p b) =&gt; p -&gt; <a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b (<a href="Diagrams-Core-V.html#t:V">V</a> p)  </li></ul></li><li class="src short"><span class="keyword">class</span> <a href="Diagrams-Core-Transform.html#t:Transformable">Transformable</a> p =&gt; <a href="#t:IsPrim">IsPrim</a> p  <span class="keyword">where</span><ul class="subs"><li><a href="#v:transformWithFreeze">transformWithFreeze</a> :: <a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> (<a href="Diagrams-Core-V.html#t:V">V</a> p) -&gt; <a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> (<a href="Diagrams-Core-V.html#t:V">V</a> p) -&gt; p -&gt; p</li></ul></li><li class="src short"><a href="#v:nullPrim">nullPrim</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core-Types.html#t:Render">Render</a> b v)) =&gt; <a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v</li><li class="src short"><span class="keyword">class</span> (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core-Types.html#t:Render">Render</a> b v)) =&gt; <a href="#t:Backend">Backend</a> b v  <span class="keyword">where</span><ul class="subs"><li><span class="keyword">data</span> <a href="#t:Render">Render</a> b v :: *</li><li><span class="keyword">type</span> <a href="#t:Result">Result</a> b v :: *</li><li><span class="keyword">data</span> <a href="#t:Options">Options</a> b v :: *</li><li><a href="#v:withStyle">withStyle</a> :: b -&gt; <a href="Diagrams-Core-Style.html#t:Style">Style</a> v -&gt; <a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v -&gt; <a href="Diagrams-Core-Types.html#t:Render">Render</a> b v -&gt; <a href="Diagrams-Core-Types.html#t:Render">Render</a> b v</li><li><a href="#v:doRender">doRender</a> :: b -&gt; <a href="Diagrams-Core-Types.html#t:Options">Options</a> b v -&gt; <a href="Diagrams-Core-Types.html#t:Render">Render</a> b v -&gt; <a href="Diagrams-Core-Types.html#t:Result">Result</a> b v</li><li><a href="#v:adjustDia">adjustDia</a> :: <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m =&gt; b -&gt; <a href="Diagrams-Core-Types.html#t:Options">Options</a> b v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; (<a href="Diagrams-Core-Types.html#t:Options">Options</a> b v, <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</li><li><a href="#v:renderDia">renderDia</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; b -&gt; <a href="Diagrams-Core-Types.html#t:Options">Options</a> b v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:Result">Result</a> b v</li><li><a href="#v:renderData">renderData</a> :: <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m =&gt; b -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:Render">Render</a> b v</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="Diagrams-Core-Types.html#t:Backend">Backend</a> b v =&gt; <a href="#t:MultiBackend">MultiBackend</a> b v  <span class="keyword">where</span><ul class="subs"><li><a href="#v:renderDias">renderDias</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; b -&gt; <a href="Diagrams-Core-Types.html#t:Options">Options</a> b v -&gt; [<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m] -&gt; <a href="Diagrams-Core-Types.html#t:Result">Result</a> b v</li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:DNode">DNode</a> b v a<ul class="subs"><li>= <a href="#v:DStyle">DStyle</a> (<a href="Diagrams-Core-Style.html#t:Style">Style</a> v)  </li><li>| <a href="#v:DTransform">DTransform</a> (<a href="Data-Monoid-Split.html#t:Split">Split</a> (<a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v))  </li><li>| <a href="#v:DAnnot">DAnnot</a> a  </li><li>| <a href="#v:DDelay">DDelay</a>  </li><li>| <a href="#v:DPrim">DPrim</a> (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v)  </li><li>| <a href="#v:DEmpty">DEmpty</a>  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:DTree">DTree</a> b v a = <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (<a href="Diagrams-Core-Types.html#t:DNode">DNode</a> b v a)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:RNode">RNode</a> b v a<ul class="subs"><li>= <a href="#v:RStyle">RStyle</a> (<a href="Diagrams-Core-Style.html#t:Style">Style</a> v)  </li><li>| <a href="#v:RFrozenTr">RFrozenTr</a> (<a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v)  </li><li>| <a href="#v:RAnnot">RAnnot</a> a  </li><li>| <a href="#v:RPrim">RPrim</a> (<a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v) (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v)  </li><li>| <a href="#v:REmpty">REmpty</a>  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:RTree">RTree</a> b v a = <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (<a href="Diagrams-Core-Types.html#t:RNode">RNode</a> b v a)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:NullBackend">NullBackend</a> </li><li class="src short"><span class="keyword">type</span> <a href="#t:D">D</a> v = <a href="Diagrams-Core-Types.html#t:Diagram">Diagram</a> <a href="Diagrams-Core-Types.html#t:NullBackend">NullBackend</a> v</li><li class="src short"><span class="keyword">class</span> <a href="Diagrams-Core-Transform.html#t:Transformable">Transformable</a> t =&gt; <a href="#t:Renderable">Renderable</a> t b  <span class="keyword">where</span><ul class="subs"><li><a href="#v:render">render</a> :: b -&gt; t -&gt; <a href="Diagrams-Core-Types.html#t:Render">Render</a> b (<a href="Diagrams-Core-V.html#t:V">V</a> t)</li></ul></li></ul></div><div id="interface"><h1 id="g:1">Diagrams
</h1><h2 id="g:2">Annotations
</h2><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:UpAnnots" class="def">UpAnnots</a> b v m = <a href="Data-Monoid-Deletable.html#t:Deletable">Deletable</a> (<a href="Diagrams-Core-Envelope.html#t:Envelope">Envelope</a> v) <a href="Data-Monoid-MList.html#t::::">:::</a> (<a href="Data-Monoid-Deletable.html#t:Deletable">Deletable</a> (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v) <a href="Data-Monoid-MList.html#t::::">:::</a> (<a href="Data-Monoid-Deletable.html#t:Deletable">Deletable</a> (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m) <a href="Data-Monoid-MList.html#t::::">:::</a> (<a href="Diagrams-Core-Query.html#t:Query">Query</a> v m <a href="Data-Monoid-MList.html#t::::">:::</a> ())))<a href="src/Diagrams-Core-Types.html#UpAnnots" class="link">Source</a></p><div class="doc"><p>Monoidal annotations which travel up the diagram tree, <em>i.e.</em> which
   are aggregated from component diagrams to the whole:
</p><ul><li> envelopes (see <a href="Diagrams-Core-Envelope.html">Diagrams.Core.Envelope</a>).
     The envelopes are &quot;deletable&quot; meaning that at any point we can
     throw away the existing envelope and replace it with a new one;
     sometimes we want to consider a diagram as having a different
     envelope unrelated to its &quot;natural&quot; envelope.
</li><li> traces (see <a href="Diagrams-Core-Trace.html">Diagrams.Core.Trace</a>), also
     deletable.
</li><li> name/subdiagram associations (see <a href="Diagrams-Core-Names.html">Diagrams.Core.Names</a>)
</li><li> query functions (see <a href="Diagrams-Core-Query.html">Diagrams.Core.Query</a>)
</li></ul></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:DownAnnots" class="def">DownAnnots</a> v = (<a href="Data-Monoid-Split.html#t:Split">Split</a> (<a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v) <a href="Data-Monoid-Coproduct.html#t::-43-:">:+:</a> <a href="Diagrams-Core-Style.html#t:Style">Style</a> v) <a href="Data-Monoid-MList.html#t::::">:::</a> (<a href="Diagrams-Core-Names.html#t:Name">Name</a> <a href="Data-Monoid-MList.html#t::::">:::</a> ())<a href="src/Diagrams-Core-Types.html#DownAnnots" class="link">Source</a></p><div class="doc"><p>Monoidal annotations which travel down the diagram tree,
   <em>i.e.</em> which accumulate along each path to a leaf (and which can
   act on the upwards-travelling annotations):
</p><ul><li> transformations (split at the innermost freeze): see
     <a href="Diagrams-Core-Transform.html">Diagrams.Core.Transform</a>
</li><li> styles (see <a href="Diagrams-Core-Style.html">Diagrams.Core.Style</a>)
</li><li> names (see <a href="Diagrams-Core-Names.html">Diagrams.Core.Names</a>)
</li></ul></div></div><div class="top"><p class="src"><a name="v:transfToAnnot" class="def">transfToAnnot</a> ::  <a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v -&gt; <a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v<a href="src/Diagrams-Core-Types.html#transfToAnnot" class="link">Source</a></p><div class="doc"><p>Inject a transformation into a default downwards annotation
   value.
</p></div></div><div class="top"><p class="src"><a name="v:transfFromAnnot" class="def">transfFromAnnot</a> :: <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v -&gt; <a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v<a href="src/Diagrams-Core-Types.html#transfFromAnnot" class="link">Source</a></p><div class="doc"><p>Extract the (total) transformation from a downwards annotation
   value.
</p></div></div><h2 id="g:3">Basic type definitions
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:QDiaLeaf" class="def">QDiaLeaf</a> b v m <a href="src/Diagrams-Core-Types.html#QDiaLeaf" class="link">Source</a></p><div class="doc"><p>A leaf in a <code><a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a></code> tree is either a <code><a href="Diagrams-Core-Types.html#t:Prim">Prim</a></code>, or a &quot;delayed&quot;
   <code>QDiagram</code> which expands to a real <code>QDiagram</code> once it learns the
   &quot;final context&quot; in which it will be rendered.  For example, in
   order to decide how to draw an arrow, we must know the precise
   transformation applied to it (since the arrow head and tail are
   scale-invariant).
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:PrimLeaf" class="def">PrimLeaf</a> (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:DelayedLeaf" class="def">DelayedLeaf</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>The <code>QDiagram</code> produced by a <code>DelayedLeaf</code> function <em>must</em>
   already apply any non-frozen transformation in the given
   <code>DownAnnots</code> (that is, the non-frozen transformation will not
   be applied by the context). On the other hand, it must assume
   that any frozen transformation or attributes will be applied
   by the context.
</p></td></tr></table></div><div class="subs instances"><p id="control.i:QDiaLeaf" class="caption collapser" onclick="toggleSection('i:QDiaLeaf')">Instances</p><div id="section.i:QDiaLeaf" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> (<a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Wrapped.html#t:Wrapped">Wrapped</a> (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b v m)) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v') (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b' v' m') () (<a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b' v' m')) (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b' v' m')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:withQDiaLeaf" class="def">withQDiaLeaf</a> ::  (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v -&gt; r) -&gt; ((<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) -&gt; r) -&gt; <a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b v m -&gt; r<a href="src/Diagrams-Core-Types.html#withQDiaLeaf" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:QDiagram" class="def">QDiagram</a> b v m <a href="src/Diagrams-Core-Types.html#QDiagram" class="link">Source</a></p><div class="doc"><p>The fundamental diagram type is represented by trees of
   primitives with various monoidal annotations.  The <code>Q</code> in
   <code>QDiagram</code> stands for &quot;Queriable&quot;, as distinguished from
   <code><a href="Diagrams-Core-Types.html#t:Diagram">Diagram</a></code>, a synonym for <code>QDiagram</code> with the query type
   specialized to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a></code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:QD" class="def">QD</a> (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b v m))</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:QDiagram" class="caption collapser" onclick="toggleSection('i:QDiagram')">Instances</p><div id="section.i:QDiagram" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable3">Typeable3</a> <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Diagrams form a monoid since each of their components do: the
   empty diagram has no primitives, an empty envelope, an empty
   trace, no named subdiagrams, and a constantly empty query
   function.
</p><p>Diagrams compose by aligning their respective local origins.  The
   new diagram has all the primitives and all the names from the two
   diagrams combined, and query functions are combined pointwise.
   The first diagram goes on top of the second.  &quot;On top of&quot;
   probably only makes sense in vector spaces of dimension lower
   than 3, but in theory it could make sense for, say, 3-dimensional
   diagrams when viewed by 4-dimensional beings.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-HasOrigin.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Every diagram has an intrinsic &quot;local origin&quot; which is the
   basis for all combining operations.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Transform.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Diagrams can be transformed by transforming each of their
   components appropriately.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Names.html#t:Qualifiable">Qualifiable</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Diagrams can be qualified so that all their named points can
   now be referred to using the qualification prefix.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Style.html#t:HasStyle">HasStyle</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; <a href="Diagrams-Core-Envelope.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; <a href="Diagrams-Core-Juxtapose.html#t:Juxtaposable">Juxtaposable</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Wrapped.html#t:Wrapped">Wrapped</a> (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b v m)) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v') (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b' v' m') () (<a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b' v' m')) (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b' v' m')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Diagram" class="def">Diagram</a> b v = <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a><a href="src/Diagrams-Core-Types.html#Diagram" class="link">Source</a></p><div class="doc"><p>The default sort of diagram is one where querying at a point
   simply tells you whether the diagram contains that point or not.
   Transforming a default diagram into one with a more interesting
   query can be done via the <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a></code> instance of <code><code><a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a></code> b</code> or
   the <code><a href="Diagrams-Core-Types.html#v:value">value</a></code> function.
</p></div></div><h1 id="g:4">Operations on diagrams
</h1><h2 id="g:5">Creating diagrams
</h2><div class="top"><p class="src"><a name="v:mkQD" class="def">mkQD</a> ::  <a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v -&gt; <a href="Diagrams-Core-Envelope.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m -&gt; <a href="Diagrams-Core-Query.html#t:Query">Query</a> v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#mkQD" class="link">Source</a></p><div class="doc"><p>Create a diagram from a single primitive, along with an envelope,
   trace, subdiagram map, and query function.
</p></div></div><div class="top"><p class="src"><a name="v:mkQD-39-" class="def">mkQD'</a> ::  <a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b v m -&gt; <a href="Diagrams-Core-Envelope.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m -&gt; <a href="Diagrams-Core-Query.html#t:Query">Query</a> v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#mkQD%27" class="link">Source</a></p><div class="doc"><p>Create a diagram from a generic QDiaLeaf, along with an envelope,
   trace, subdiagram map, and query function.
</p></div></div><div class="top"><p class="src"><a name="v:pointDiagram" class="def">pointDiagram</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v) =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#pointDiagram" class="link">Source</a></p><div class="doc"><p>Create a &quot;point diagram&quot;, which has no content, no trace, an
   empty query, and a point envelope.
</p></div></div><h2 id="g:6">Extracting information
</h2><div class="top"><p class="src"><a name="v:prims" class="def">prims</a> :: <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; [(<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v, (<a href="Data-Monoid-Split.html#t:Split">Split</a> (<a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v), <a href="Diagrams-Core-Style.html#t:Style">Style</a> v))]<a href="src/Diagrams-Core-Types.html#prims" class="link">Source</a></p><div class="doc"><p>Extract a list of primitives from a diagram, together with their
   associated transformations and styles.
</p></div></div><div class="top"><p class="src"><a name="v:envelope" class="def">envelope</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Type.html#t:Lens-39-">Lens'</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Envelope.html#t:Envelope">Envelope</a> v)<a href="src/Diagrams-Core-Types.html#envelope" class="link">Source</a></p><div class="doc"><p>Get the envelope of a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:trace" class="def">trace</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Type.html#t:Lens-39-">Lens'</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v)<a href="src/Diagrams-Core-Types.html#trace" class="link">Source</a></p><div class="doc"><p>Get the trace of a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:subMap" class="def">subMap</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Type.html#t:Lens-39-">Lens'</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m)<a href="src/Diagrams-Core-Types.html#subMap" class="link">Source</a></p><div class="doc"><p>Get the subdiagram map (<em>i.e.</em> an association from names to
   subdiagrams) of a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:names" class="def">names</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; [(<a href="Diagrams-Core-Names.html#t:Name">Name</a>, [<a href="Diagrams-Core-Points.html#t:Point">Point</a> v])]<a href="src/Diagrams-Core-Types.html#names" class="link">Source</a></p><div class="doc"><p>Get a list of names of subdiagrams and their locations.
</p></div></div><div class="top"><p class="src"><a name="v:query" class="def">query</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Query.html#t:Query">Query</a> v m<a href="src/Diagrams-Core-Types.html#query" class="link">Source</a></p><div class="doc"><p>Get the query function associated with a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:sample" class="def">sample</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; m<a href="src/Diagrams-Core-Types.html#sample" class="link">Source</a></p><div class="doc"><p>Sample a diagram's query function at a given point.
</p></div></div><div class="top"><p class="src"><a name="v:value" class="def">value</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a> -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#value" class="link">Source</a></p><div class="doc"><p>Set the query value for <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></code> points in a diagram (<em>i.e.</em> points
   &quot;inside&quot; the diagram); <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></code> points will be set to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#v:mempty">mempty</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:resetValue" class="def">resetValue</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a><a href="src/Diagrams-Core-Types.html#resetValue" class="link">Source</a></p><div class="doc"><p>Reset the query values of a diagram to <code>True</code>/<code>False</code>: any values
   equal to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#v:mempty">mempty</a></code> are set to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></code>; any other values are set to
   <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:clearValue" class="def">clearValue</a> ::  <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a><a href="src/Diagrams-Core-Types.html#clearValue" class="link">Source</a></p><div class="doc"><p>Set all the query values of a diagram to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></code>.
</p></div></div><h2 id="g:7">Combining diagrams
</h2><div class="doc"><p>For many more ways of combining diagrams, see
 <a href="Diagrams-Combinators.html">Diagrams.Combinators</a> from the diagrams-lib package.
</p></div><div class="top"><p class="src"><a name="v:atop" class="def">atop</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#atop" class="link">Source</a></p><div class="doc"><p>A convenient synonym for <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#v:mappend">mappend</a></code> on diagrams, designed to be
   used infix (to help remember which diagram goes on top of which
   when combining them, namely, the first on top of the second).
</p></div></div><h2 id="g:8">Modifying diagrams
</h2><h3 id="g:9">Names
</h3><div class="top"><p class="src"><a name="v:nameSub" class="def">nameSub</a> :: (<a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m) -&gt; n -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#nameSub" class="link">Source</a></p><div class="doc"><p>Attach an atomic name to a certain subdiagram, computed from the
   given diagram.
</p></div></div><div class="top"><p class="src"><a name="v:lookupName" class="def">lookupName</a> :: (<a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; n -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m)<a href="src/Diagrams-Core-Types.html#lookupName" class="link">Source</a></p><div class="doc"><p>Lookup the most recent diagram associated with (some
   qualification of) the given name.
</p></div></div><div class="top"><p class="src"><a name="v:withName" class="def">withName</a> :: (<a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; n -&gt; (<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#withName" class="link">Source</a></p><div class="doc"><p>Given a name and a diagram transformation indexed by a
   subdiagram, perform the transformation using the most recent
   subdiagram associated with (some qualification of) the name,
   or perform the identity transformation if the name does not exist.
</p></div></div><div class="top"><p class="src"><a name="v:withNameAll" class="def">withNameAll</a> :: (<a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; n -&gt; ([<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m] -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#withNameAll" class="link">Source</a></p><div class="doc"><p>Given a name and a diagram transformation indexed by a list of
   subdiagrams, perform the transformation using the
   collection of all such subdiagrams associated with (some
   qualification of) the given name.
</p></div></div><div class="top"><p class="src"><a name="v:withNames" class="def">withNames</a> :: (<a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; [n] -&gt; ([<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m] -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#withNames" class="link">Source</a></p><div class="doc"><p>Given a list of names and a diagram transformation indexed by a
   list of subdiagrams, perform the transformation using the
   list of most recent subdiagrams associated with (some qualification
   of) each name.  Do nothing (the identity transformation) if any
   of the names do not exist.
</p></div></div><div class="top"><p class="src"><a name="v:localize" class="def">localize</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#localize" class="link">Source</a></p><div class="doc"><p>&quot;Localize&quot; a diagram by hiding all the names, so they are no
   longer visible to the outside.
</p></div></div><h3 id="g:10">Other
</h3><div class="top"><p class="src"><a name="v:freeze" class="def">freeze</a> :: <span class="keyword">forall</span> v b m. (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#freeze" class="link">Source</a></p><div class="doc"><p>By default, diagram attributes are not affected by
   transformations.  This means, for example, that <code>lw 0.01 circle</code>
   and <code>scale 2 (lw 0.01 circle)</code> will be drawn with lines of the
   <em>same</em> width, and <code>scaleY 3 circle</code> will be an ellipse drawn with
   a uniform line.  Once a diagram is frozen, however,
   transformations do affect attributes, so, for example, <code>scale 2
   (freeze (lw 0.01 circle))</code> will be drawn with a line twice as
   thick as <code>lw 0.01 circle</code>, and <code>scaleY 3 (freeze circle)</code> will be
   drawn with a &quot;stretched&quot;, variable-width line.
</p><p>Another way of thinking about it is that pre-<code>freeze</code>, we are
   transforming the &quot;abstract idea&quot; of a diagram, and the
   transformed version is then drawn; when doing a <code>freeze</code>, we
   produce a concrete drawing of the diagram, and it is this visual
   representation itself which is acted upon by subsequent
   transformations.
</p></div></div><div class="top"><p class="src"><a name="v:setEnvelope" class="def">setEnvelope</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; <a href="Diagrams-Core-Envelope.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#setEnvelope" class="link">Source</a></p><div class="doc"><p>Replace the envelope of a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:setTrace" class="def">setTrace</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#setTrace" class="link">Source</a></p><div class="doc"><p>Replace the trace of a diagram.
</p></div></div><h1 id="g:11">Subdiagrams
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Subdiagram" class="def">Subdiagram</a> b v m <a href="src/Diagrams-Core-Types.html#Subdiagram" class="link">Source</a></p><div class="doc"><p>A <code>Subdiagram</code> represents a diagram embedded within the context
   of a larger diagram.  Essentially, it consists of a diagram
   paired with any accumulated information from the larger context
   (transformations, attributes, etc.).
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Subdiagram" class="def">Subdiagram</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Subdiagram" class="caption collapser" onclick="toggleSection('i:Subdiagram')">Instances</p><div id="section.i:Subdiagram" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> (<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Wrapped.html#t:Wrapped">Wrapped</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core-Names.html#t:Name">Name</a> [<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m]) (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core-Names.html#t:Name">Name</a> [<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m']) (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m) (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m')</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core-HasOrigin.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core-Transform.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; <a href="Diagrams-Core-Envelope.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:mkSubdiagram" class="def">mkSubdiagram</a> ::  <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m<a href="src/Diagrams-Core-Types.html#mkSubdiagram" class="link">Source</a></p><div class="doc"><p>Turn a diagram into a subdiagram with no accumulated context.
</p></div></div><div class="top"><p class="src"><a name="v:getSub" class="def">getSub</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#getSub" class="link">Source</a></p><div class="doc"><p>Turn a subdiagram into a normal diagram, including the enclosing
   context.  Concretely, a subdiagram is a pair of (1) a diagram and
   (2) a &quot;context&quot; consisting of an extra transformation and
   attributes.  <code>getSub</code> simply applies the transformation and
   attributes to the diagram to get the corresponding &quot;top-level&quot;
   diagram.
</p></div></div><div class="top"><p class="src"><a name="v:rawSub" class="def">rawSub</a> ::  <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#rawSub" class="link">Source</a></p><div class="doc"><p>Extract the &quot;raw&quot; content of a subdiagram, by throwing away the
   context.
</p></div></div><div class="top"><p class="src"><a name="v:location" class="def">location</a> :: <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> v<a href="src/Diagrams-Core-Types.html#location" class="link">Source</a></p><div class="doc"><p>Get the location of a subdiagram; that is, the location of its
   local origin <em>with respect to</em> the vector space of its parent
   diagram.  In other words, the point where its local origin
   &quot;ended up&quot;.
</p></div></div><div class="top"><p class="src"><a name="v:subPoint" class="def">subPoint</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m<a href="src/Diagrams-Core-Types.html#subPoint" class="link">Source</a></p><div class="doc"><p>Create a &quot;point subdiagram&quot;, that is, a <code><a href="Diagrams-Core-Types.html#v:pointDiagram">pointDiagram</a></code> (with no
   content and a point envelope) treated as a subdiagram with local
   origin at the given point.  Note this is not the same as
   <code>mkSubdiagram . pointDiagram</code>, which would result in a subdiagram
   with local origin at the parent origin, rather than at the given
   point.
</p></div></div><h1 id="g:12">Subdiagram maps
</h1><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:SubMap" class="def">SubMap</a> b v m <a href="src/Diagrams-Core-Types.html#SubMap" class="link">Source</a></p><div class="doc"><p>A <code><a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a></code> is a map associating names to subdiagrams. There can
   be multiple associations for any given name.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:SubMap" class="def">SubMap</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core-Names.html#t:Name">Name</a> [<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m])</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:SubMap" class="caption collapser" onclick="toggleSection('i:SubMap')">Instances</p><div id="section.i:SubMap" class="show"><table><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core-Names.html#t:Name">Name</a> (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m)</td><td class="doc"><p>A name acts on a name map by qualifying every name in it.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Wrapped.html#t:Wrapped">Wrapped</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core-Names.html#t:Name">Name</a> [<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m]) (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core-Names.html#t:Name">Name</a> [<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m']) (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m) (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m')</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m)</td><td class="doc"><p><code><a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a></code>s form a monoid with the empty map as the identity, and
   map union as the binary operation.  No information is ever lost:
   if two maps have the same name in their domain, the resulting map
   will associate that name to the concatenation of the information
   associated with that name.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core-HasOrigin.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core-Transform.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Names.html#t:Qualifiable">Qualifiable</a> (<a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m)</td><td class="doc"><p><code><a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a></code>s are qualifiable: if <code>ns</code> is a <code><a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a></code>, then <code>a |&gt;
   ns</code> is the same <code><a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a></code> except with every name qualified by
   <code>a</code>.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/lens/3.10/doc/html/Control-Lens-Wrapped.html#t:Wrapped">Wrapped</a> (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b v m)) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v') (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b' v' m') () (<a href="Diagrams-Core-Types.html#t:QDiaLeaf">QDiaLeaf</a> b' v' m')) (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b' v' m')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:fromNames" class="def">fromNames</a> :: <a href="Diagrams-Core-Names.html#t:IsName">IsName</a> a =&gt; [(a, <a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m)] -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m<a href="src/Diagrams-Core-Types.html#fromNames" class="link">Source</a></p><div class="doc"><p>Construct a <code><a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a></code> from a list of associations between names
   and subdiagrams.
</p></div></div><div class="top"><p class="src"><a name="v:rememberAs" class="def">rememberAs</a> :: <a href="Diagrams-Core-Names.html#t:IsName">IsName</a> a =&gt; a -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m<a href="src/Diagrams-Core-Types.html#rememberAs" class="link">Source</a></p><div class="doc"><p>Add a name/diagram association to a submap.
</p></div></div><div class="top"><p class="src"><a name="v:lookupSub" class="def">lookupSub</a> :: <a href="Diagrams-Core-Names.html#t:IsName">IsName</a> n =&gt; n -&gt; <a href="Diagrams-Core-Types.html#t:SubMap">SubMap</a> b v m -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> [<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m]<a href="src/Diagrams-Core-Types.html#lookupSub" class="link">Source</a></p><div class="doc"><p>Look for the given name in a name map, returning a list of
   subdiagrams associated with that name.  If no names match the
   given name exactly, return all the subdiagrams associated with
   names of which the given name is a suffix.
</p></div></div><h1 id="g:13">Primtives
</h1><div class="doc"><p>Ultimately, every diagram is essentially a list of <em>primitives</em>,
 basic building blocks which can be rendered by backends.  However,
 not every backend must be able to render every type of primitive;
 the collection of primitives a given backend knows how to render is
 determined by instances of <code><a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a></code>.
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Prim" class="def">Prim</a> b v <span class="keyword">where</span><a href="src/Diagrams-Core-Types.html#Prim" class="link">Source</a></p><div class="doc"><p>A value of type <code>Prim b v</code> is an opaque (existentially quantified)
   primitive which backend <code>b</code> knows how to render in vector space <code>v</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Prim" class="def">Prim</a> :: (<a href="Diagrams-Core-Types.html#t:IsPrim">IsPrim</a> p, <a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> p b) =&gt; p -&gt; <a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b (<a href="Diagrams-Core-V.html#t:V">V</a> p)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Prim" class="caption collapser" onclick="toggleSection('i:Prim')">Instances</p><div id="section.i:Prim" class="show"><table><tr><td class="src"><a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Transform.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v)</td><td class="doc"><p>The <code><a href="Diagrams-Core-Transform.html#t:Transformable">Transformable</a></code> instance for <code><a href="Diagrams-Core-Types.html#t:Prim">Prim</a></code> just pushes calls to
   <code><a href="Diagrams-Core-Transform.html#v:transform">transform</a></code> down through the <code><a href="Diagrams-Core-Types.html#t:Prim">Prim</a></code> constructor.
</p></td></tr><tr><td class="src"><a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:IsPrim">IsPrim</a> (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v) b</td><td class="doc"><p>The <code><a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a></code> instance for <code><a href="Diagrams-Core-Types.html#t:Prim">Prim</a></code> just pushes calls to
   <code><a href="Diagrams-Core-Types.html#v:render">render</a></code> down through the <code><a href="Diagrams-Core-Types.html#t:Prim">Prim</a></code> constructor.
</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="Diagrams-Core-Transform.html#t:Transformable">Transformable</a> p =&gt; <a name="t:IsPrim" class="def">IsPrim</a> p  <span class="keyword">where</span><a href="src/Diagrams-Core-Types.html#IsPrim" class="link">Source</a></p><div class="doc"><p>A type class for primitive things which know how to handle being
   transformed by both a normal transformation and a &quot;frozen&quot;
   transformation.  The default implementation simply applies both.
   At the moment, <code>ScaleInv</code> is the only type with a non-default
   instance of <code><a href="Diagrams-Core-Types.html#t:IsPrim">IsPrim</a></code>.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:transformWithFreeze" class="def">transformWithFreeze</a> :: <a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> (<a href="Diagrams-Core-V.html#t:V">V</a> p) -&gt; <a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> (<a href="Diagrams-Core-V.html#t:V">V</a> p) -&gt; p -&gt; p<a href="src/Diagrams-Core-Types.html#transformWithFreeze" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:IsPrim" class="caption collapser" onclick="toggleSection('i:IsPrim')">Instances</p><div id="section.i:IsPrim" class="show"><table><tr><td class="src"><a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:IsPrim">IsPrim</a> (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:nullPrim" class="def">nullPrim</a> :: (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core-Types.html#t:Render">Render</a> b v)) =&gt; <a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v<a href="src/Diagrams-Core-Types.html#nullPrim" class="link">Source</a></p><div class="doc"><p>The null primitive, which every backend can render by doing
   nothing.
</p></div></div><h1 id="g:14">Backends
</h1><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core-Types.html#t:Render">Render</a> b v)) =&gt; <a name="t:Backend" class="def">Backend</a> b v  <span class="keyword">where</span><a href="src/Diagrams-Core-Types.html#Backend" class="link">Source</a></p><div class="doc"><p>Abstract diagrams are rendered to particular formats by
   <em>backends</em>.  Each backend/vector space combination must be an
   instance of the <code><a href="Diagrams-Core-Types.html#t:Backend">Backend</a></code> class. A minimal complete definition
   consists of the three associated types, an implementation for
   <code><a href="Diagrams-Core-Types.html#v:doRender">doRender</a></code>, and <em>one of</em> either <code><a href="Diagrams-Core-Types.html#v:withStyle">withStyle</a></code> or <code><a href="Diagrams-Core-Types.html#v:renderData">renderData</a></code>.
</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">data</span> <a name="t:Render" class="def">Render</a> b v :: *<a href="src/Diagrams-Core-Types.html#Render" class="link">Source</a></p><div class="doc"><p>The type of rendering operations used by this backend, which
   must be a monoid. For example, if <code>Render b v = M ()</code> for some
   monad <code>M</code>, a monoid instance can be made with <code>mempty = return
   ()</code> and <code>mappend = (&gt;&gt;)</code>.
</p></div><p class="src"><span class="keyword">type</span> <a name="t:Result" class="def">Result</a> b v :: *<a href="src/Diagrams-Core-Types.html#Result" class="link">Source</a></p><div class="doc"><p>The result of running/interpreting a rendering operation.
</p></div><p class="src"><span class="keyword">data</span> <a name="t:Options" class="def">Options</a> b v :: *<a href="src/Diagrams-Core-Types.html#Options" class="link">Source</a></p><div class="doc"><p>Backend-specific rendering options.
</p></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:withStyle" class="def">withStyle</a><a href="src/Diagrams-Core-Types.html#withStyle" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: b</td><td class="doc"><p>Backend token (needed only for type inference)
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core-Style.html#t:Style">Style</a> v</td><td class="doc"><p>Style to use
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v</td><td class="doc"><p>&quot;Frozen&quot; transformation; line width and
   other similar &quot;scale invariant&quot; attributes
   should be affected by this transformation.
   In the case of 2D, some backends may not
   support stroking in the context of an
   arbitrary transformation; such backends can
   instead use the <code>avgScale</code> function from
   <a href="Diagrams-TwoD-Transform.html">Diagrams.TwoD.Transform</a> (from the
   <code>diagrams-lib</code> package).
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core-Types.html#t:Render">Render</a> b v</td><td class="doc"><p>Rendering operation to run
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core-Types.html#t:Render">Render</a> b v</td><td class="doc"><p>Rendering operation using the style locally
</p></td></tr></table></div><div class="doc"><p>Perform a rendering operation with a local style. The default
   implementation does nothing, and must be overridden by backends
   that do not override <code><a href="Diagrams-Core-Types.html#v:renderData">renderData</a></code>.
</p></div><p class="src"><a name="v:doRender" class="def">doRender</a><a href="src/Diagrams-Core-Types.html#doRender" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: b</td><td class="doc"><p>Backend token (needed only for type inference)
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core-Types.html#t:Options">Options</a> b v</td><td class="doc"><p>Backend-specific collection of rendering options
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core-Types.html#t:Render">Render</a> b v</td><td class="doc"><p>Rendering operation to perform
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core-Types.html#t:Result">Result</a> b v</td><td class="doc"><p>Output of the rendering operation
</p></td></tr></table></div><div class="doc"><p><code><a href="Diagrams-Core-Types.html#v:doRender">doRender</a></code> is used to interpret rendering operations.
</p></div><p class="src"><a name="v:adjustDia" class="def">adjustDia</a> :: <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m =&gt; b -&gt; <a href="Diagrams-Core-Types.html#t:Options">Options</a> b v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; (<a href="Diagrams-Core-Types.html#t:Options">Options</a> b v, <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)<a href="src/Diagrams-Core-Types.html#adjustDia" class="link">Source</a></p><div class="doc"><p><code><a href="Diagrams-Core-Types.html#v:adjustDia">adjustDia</a></code> allows the backend to make adjustments to the final
   diagram (e.g. to adjust the size based on the options) before
   rendering it.  It can also make adjustments to the options
   record, usually to fill in incompletely specified size
   information.  A default implementation is provided which makes
   no adjustments.  See the diagrams-lib package for other useful
   implementations.
</p></div><p class="src"><a name="v:renderDia" class="def">renderDia</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; b -&gt; <a href="Diagrams-Core-Types.html#t:Options">Options</a> b v -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:Result">Result</a> b v<a href="src/Diagrams-Core-Types.html#renderDia" class="link">Source</a></p><p class="src"><a name="v:renderData" class="def">renderData</a> :: <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m =&gt; b -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core-Types.html#t:Render">Render</a> b v<a href="src/Diagrams-Core-Types.html#renderData" class="link">Source</a></p><div class="doc"><p>Backends may override <code><a href="Diagrams-Core-Types.html#v:renderData">renderData</a></code> to gain more control over
   the way that rendering happens.  A typical implementation might be something like
</p><pre> renderData = renderRTree . toRTree
</pre><p>where <code>renderRTree :: RTree b v () -&gt; Render b v</code> is
   implemented by the backend (with appropriate types filled in
   for <code>b</code> and <code>v</code>), and <code>toRTree</code> is from <a href="Diagrams-Core-Compile.html">Diagrams.Core.Compile</a>.
</p></div></div><div class="subs instances"><p id="control.i:Backend" class="caption collapser" onclick="toggleSection('i:Backend')">Instances</p><div id="section.i:Backend" class="show"><table><tr><td class="src"><a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:Backend">Backend</a> <a href="Diagrams-Core-Types.html#t:NullBackend">NullBackend</a> v</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="Diagrams-Core-Types.html#t:Backend">Backend</a> b v =&gt; <a name="t:MultiBackend" class="def">MultiBackend</a> b v  <span class="keyword">where</span><a href="src/Diagrams-Core-Types.html#MultiBackend" class="link">Source</a></p><div class="doc"><p>A class for backends which support rendering multiple diagrams,
   e.g. to a multi-page pdf or something similar.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:renderDias" class="def">renderDias</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; b -&gt; <a href="Diagrams-Core-Types.html#t:Options">Options</a> b v -&gt; [<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m] -&gt; <a href="Diagrams-Core-Types.html#t:Result">Result</a> b v<a href="src/Diagrams-Core-Types.html#renderDias" class="link">Source</a></p><div class="doc"><p>Render multiple diagrams at once.
</p></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:DNode" class="def">DNode</a> b v a <a href="src/Diagrams-Core-Types.html#DNode" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DStyle" class="def">DStyle</a> (<a href="Diagrams-Core-Style.html#t:Style">Style</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:DTransform" class="def">DTransform</a> (<a href="Data-Monoid-Split.html#t:Split">Split</a> (<a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:DAnnot" class="def">DAnnot</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:DDelay" class="def">DDelay</a></td><td class="doc"><p><code>DDelay</code> marks a point where a delayed subtree
   was expanded.  Such subtrees already take all
   non-frozen transforms above them into account,
   so when later processing the tree, upon
   encountering a <code>DDelay</code> node we must drop any
   accumulated non-frozen transformation.
</p></td></tr><tr><td class="src"><a name="v:DPrim" class="def">DPrim</a> (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:DEmpty" class="def">DEmpty</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:DTree" class="def">DTree</a> b v a = <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (<a href="Diagrams-Core-Types.html#t:DNode">DNode</a> b v a)<a href="src/Diagrams-Core-Types.html#DTree" class="link">Source</a></p><div class="doc"><p>A <code><a href="Diagrams-Core-Types.html#t:DTree">DTree</a></code> is a raw tree representation of a <code><a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a></code>, with all
   the <code>u</code>-annotations removed.  It is used as an intermediate type
   by diagrams-core; backends should not need to make use of it.
   Instead, backends can make use of <code><a href="Diagrams-Core-Types.html#t:RTree">RTree</a></code>, which <code><a href="Diagrams-Core-Types.html#t:DTree">DTree</a></code> gets
   compiled and optimized to.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:RNode" class="def">RNode</a> b v a <a href="src/Diagrams-Core-Types.html#RNode" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:RStyle" class="def">RStyle</a> (<a href="Diagrams-Core-Style.html#t:Style">Style</a> v)</td><td class="doc"><p>A style node.
</p></td></tr><tr><td class="src"><a name="v:RFrozenTr" class="def">RFrozenTr</a> (<a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v)</td><td class="doc"><p>A &quot;frozen&quot; transformation, <em>i.e.</em> one which
   was applied after a call to <code><a href="Diagrams-Core-Types.html#v:freeze">freeze</a></code>.  It
   applies to everything below it in the tree.
   Note that line width and other similar
   &quot;scale invariant&quot; attributes should be
   affected by this transformation.  In the case
   of 2D, some backends may not support stroking
   in the context of an arbitrary
   transformation; such backends can instead use
   the <code>avgScale</code> function from
   <a href="Diagrams-TwoD-Transform.html">Diagrams.TwoD.Transform</a> (from the
   <code>diagrams-lib</code> package).
</p></td></tr><tr><td class="src"><a name="v:RAnnot" class="def">RAnnot</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:RPrim" class="def">RPrim</a> (<a href="Diagrams-Core-Transform.html#t:Transformation">Transformation</a> v) (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v)</td><td class="doc"><p>A primitive, along with the (non-frozen)
   transformation which applies to it.
</p></td></tr><tr><td class="src"><a name="v:REmpty" class="def">REmpty</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:RTree" class="def">RTree</a> b v a = <a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html#t:Tree">Tree</a> (<a href="Diagrams-Core-Types.html#t:RNode">RNode</a> b v a)<a href="src/Diagrams-Core-Types.html#RTree" class="link">Source</a></p><div class="doc"><p>An <code><a href="Diagrams-Core-Types.html#t:RTree">RTree</a></code> is a compiled and optimized representation of a
   <code><a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a></code>, which can be used by backends.  They have several
   invariants which backends may rely upon:
</p><ul><li> All non-frozen transformations have been pushed all the way to
     the leaves.
</li><li> <code>RPrim</code> nodes never have any children.
</li></ul></div></div><h2 id="g:15">Null backend
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:NullBackend" class="def">NullBackend</a>  <a href="src/Diagrams-Core-Types.html#NullBackend" class="link">Source</a></p><div class="doc"><p>A null backend which does no actual rendering.  It is provided
   mainly for convenience in situations where you must give a
   diagram a concrete, monomorphic type, but don't actually care
   which one.  See <code><a href="Diagrams-Core-Types.html#t:D">D</a></code> for more explanation and examples.
</p><p>It is courteous, when defining a new primitive <code>P</code>, to make an instance
</p><pre> instance Renderable P NullBackend where
   render _ _ = mempty
</pre><p>This ensures that the trick with <code><a href="Diagrams-Core-Types.html#t:D">D</a></code> annotations can be used for
   diagrams containing your primitive.
</p></div><div class="subs instances"><p id="control.i:NullBackend" class="caption collapser" onclick="toggleSection('i:NullBackend')">Instances</p><div id="section.i:NullBackend" class="show"><table><tr><td class="src"><a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:Backend">Backend</a> <a href="Diagrams-Core-Types.html#t:NullBackend">NullBackend</a> v</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core-Types.html#t:Render">Render</a> <a href="Diagrams-Core-Types.html#t:NullBackend">NullBackend</a> v)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:D" class="def">D</a> v = <a href="Diagrams-Core-Types.html#t:Diagram">Diagram</a> <a href="Diagrams-Core-Types.html#t:NullBackend">NullBackend</a> v<a href="src/Diagrams-Core-Types.html#D" class="link">Source</a></p><div class="doc"><p>The <code>D</code> type is provided for convenience in situations where you
   must give a diagram a concrete, monomorphic type, but don't care
   which one.  Such situations arise when you pass a diagram to a
   function which is polymorphic in its input but monomorphic in its
   output, such as <code>width</code>, <code>height</code>, <code>phantom</code>, or <code><a href="Diagrams-Core-Types.html#v:names">names</a></code>.  Such
   functions compute some property of the diagram, or use it to
   accomplish some other purpose, but do not result in the diagram
   being rendered.  If the diagram does not have a monomorphic type,
   GHC complains that it cannot determine the diagram's type.
</p><p>For example, here is the error we get if we try to compute the
   width of an image (this example requires <code>diagrams-lib</code>):
</p><pre> ghci&gt; width (image &quot;foo.png&quot; 200 200)

 &lt;interactive&gt;:8:8:
     No instance for (Renderable Diagrams.TwoD.Image.Image b0)
       arising from a use of `image'
     Possible fix:
       add an instance declaration for
       (Renderable Diagrams.TwoD.Image.Image b0)
     In the first argument of `width', namely
       `(image &quot;foo.png&quot; 200 200)'
     In the expression: width (image &quot;foo.png&quot; 200 200)
     In an equation for `it': it = width (image &quot;foo.png&quot; 200 200)
</pre><p>GHC complains that there is no instance for <code>Renderable Image
   b0</code>; what is really going on is that it does not have enough
   information to decide what backend to use (hence the
   uninstantiated <code>b0</code>). This is annoying because <em>we</em> know that the
   choice of backend cannot possibly affect the width of the image
   (it's 200! it's right there in the code!); <em>but</em> there is no way
   for GHC to know that.
</p><p>The solution is to annotate the call to <code>image</code> with the type
   <code><code><a href="Diagrams-Core-Types.html#t:D">D</a></code> <code>R2</code></code>, like so:
</p><pre> ghci&gt; width (image &quot;foo.png&quot; 200 200 :: D R2)
 200.00000000000006
</pre><p>(It turns out the width wasn't 200 after all...)
</p><p>As another example, here is the error we get if we try to compute
   the width of a radius-1 circle:
</p><pre> ghci&gt; width (circle 1)

 &lt;interactive&gt;:4:1:
     Couldn't match type `V a0' with `R2'
     In the expression: width (circle 1)
     In an equation for `it': it = width (circle 1)
</pre><p>There's even more ambiguity here.  Whereas <code>image</code> always returns
   a <code><a href="Diagrams-Core-Types.html#t:Diagram">Diagram</a></code>, the <code>circle</code> function can produce any <code>PathLike</code>
   type, and the <code>width</code> function can consume any <code><a href="Diagrams-Core-Envelope.html#t:Enveloped">Enveloped</a></code> type,
   so GHC has no idea what type to pick to go in the middle.
   However, the solution is the same:
</p><pre> ghci&gt; width (circle 1 :: D R2)
 1.9999999999999998
</pre></div></div><h1 id="g:16">Renderable
</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="Diagrams-Core-Transform.html#t:Transformable">Transformable</a> t =&gt; <a name="t:Renderable" class="def">Renderable</a> t b  <span class="keyword">where</span><a href="src/Diagrams-Core-Types.html#Renderable" class="link">Source</a></p><div class="doc"><p>The Renderable type class connects backends to primitives which
   they know how to render.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:render" class="def">render</a> :: b -&gt; t -&gt; <a href="Diagrams-Core-Types.html#t:Render">Render</a> b (<a href="Diagrams-Core-V.html#t:V">V</a> t)<a href="src/Diagrams-Core-Types.html#render" class="link">Source</a></p><div class="doc"><p>Given a token representing the backend and a
   transformable object, render it in the appropriate rendering
   context.
</p></div></div><div class="subs instances"><p id="control.i:Renderable" class="caption collapser" onclick="toggleSection('i:Renderable')">Instances</p><div id="section.i:Renderable" class="show"><table><tr><td class="src"><a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v) b</td><td class="doc"><p>The <code><a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a></code> instance for <code><a href="Diagrams-Core-Types.html#t:Prim">Prim</a></code> just pushes calls to
   <code><a href="Diagrams-Core-Types.html#v:render">render</a></code> down through the <code><a href="Diagrams-Core-Types.html#t:Prim">Prim</a></code> constructor.
</p></td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2.1</p></div></body></html>