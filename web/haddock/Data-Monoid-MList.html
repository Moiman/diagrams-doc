<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Monoid.MList</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Monoid-MList.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-Monoid-MList.html">Source</a></li><li><a href="http://www.haskell.org/haskellwiki/Diagrams/Comments/Data.Monoid.MList">User Comments</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">monoid-extras-0.3.2.3: Various extra monoid-related definitions and utilities</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Maintainer</th><td>diagrams-discuss@googlegroups.com</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Data.Monoid.MList</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Heterogeneous monoidal lists
</a></li><li><a href="#g:2">Accessing embedded values
</a></li><li><a href="#g:3">Monoid actions of heterogeneous lists
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Heterogeneous lists of monoids.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t::::">:::</a> a l = (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Option">Option</a> a, l)</li><li class="src short"><a href="#v:-42-:">(*:)</a> ::  a -&gt; l -&gt; a <a href="Data-Monoid-MList.html#t::::">:::</a> l</li><li class="src short"><span class="keyword">class</span>  <a href="#t:MList">MList</a> l  <span class="keyword">where</span><ul class="subs"><li><a href="#v:empty">empty</a> :: l</li></ul></li><li class="src short"><span class="keyword">class</span>  l <a href="#t::-62-:">:&gt;:</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:inj">inj</a> :: a -&gt; l</li><li><a href="#v:get">get</a> :: l -&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Option">Option</a> a</li><li><a href="#v:alt">alt</a> :: (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Option">Option</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Option">Option</a> a) -&gt; l -&gt; l</li></ul></li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:SM">SM</a> m = <a href="#v:SM">SM</a> m</li></ul></div><div id="interface"><h1 id="g:1">Heterogeneous monoidal lists
</h1><div class="doc"><p>The idea of <em>heterogeneous lists</em> has been around for a long time.
 Here, we adopt heterogeneous lists where the element types are all
 monoids: this allows us to leave out identity values, so that a
 heterogeneous list containing only a single non-identity value can
 be created without incurring constraints due to all the other
 types, by leaving all the other values out.
</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t::::" class="def">:::</a> a l = (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Option">Option</a> a, l)<a href="src/Data-Monoid-MList.html#%3A%3A%3A" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:-42-:" class="def">(*:)</a> ::  a -&gt; l -&gt; a <a href="Data-Monoid-MList.html#t::::">:::</a> l<a href="src/Data-Monoid-MList.html#%2A%3A" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:MList" class="def">MList</a> l  <span class="keyword">where</span><a href="src/Data-Monoid-MList.html#MList" class="link">Source</a></p><div class="doc"><p>Type class for heterogeneous monoidal lists, with a single method
   allowing construction of an empty list.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:empty" class="def">empty</a> :: l<a href="src/Data-Monoid-MList.html#empty" class="link">Source</a></p><div class="doc"><p>The <em>empty</em> heterogeneous list of type <code>l</code>. Of course, <code>empty
 == <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#v:mempty">mempty</a></code></code>, but unlike <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#v:mempty">mempty</a></code>, <code>empty</code> does not require
 <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a></code> constraints on all the elements of <code>l</code>.
</p></div></div><div class="subs instances"><p id="control.i:MList" class="caption collapser" onclick="toggleSection('i:MList')">Instances</p><div id="section.i:MList" class="show"><table><tr><td class="src"><a href="Data-Monoid-MList.html#t:MList">MList</a> ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Monoid-MList.html#t:MList">MList</a> l =&gt; <a href="Data-Monoid-MList.html#t:MList">MList</a> (<a href="Data-Monoid-MList.html#t::::">:::</a> a l)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:2">Accessing embedded values
</h1><div class="top"><p class="src"><span class="keyword">class</span>  l <a name="t::-62-:" class="def">:&gt;:</a> a  <span class="keyword">where</span><a href="src/Data-Monoid-MList.html#%3A%3E%3A" class="link">Source</a></p><div class="doc"><p>The relation <code>l :&gt;: a</code> holds when <code>a</code> is the type of an element
   in <code>l</code>.  For example,  <code>(Char ::: Int ::: Bool ::: Nil) :&gt;: Int</code>.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:inj" class="def">inj</a> :: a -&gt; l<a href="src/Data-Monoid-MList.html#inj" class="link">Source</a></p><div class="doc"><p>Inject a value into an otherwise empty heterogeneous list.
</p></div><p class="src"><a name="v:get" class="def">get</a> :: l -&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Option">Option</a> a<a href="src/Data-Monoid-MList.html#get" class="link">Source</a></p><div class="doc"><p>Get the value of type <code>a</code> from a heterogeneous list, if there
   is one.
</p></div><p class="src"><a name="v:alt" class="def">alt</a> :: (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Option">Option</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Option">Option</a> a) -&gt; l -&gt; l<a href="src/Data-Monoid-MList.html#alt" class="link">Source</a></p><div class="doc"><p>Alter the value of type <code>a</code> by applying the given function to it.
</p></div></div><div class="subs instances"><p id="control.i::-62-:" class="caption collapser" onclick="toggleSection('i::-62-:')">Instances</p><div id="section.i::-62-:" class="show"><table><tr><td class="src"><a href="Data-Monoid-MList.html#t::-62-:">:&gt;:</a> t a =&gt; (<a href="Data-Monoid-MList.html#t::::">:::</a> b t) <a href="Data-Monoid-MList.html#t::-62-:">:&gt;:</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Monoid-MList.html#t:MList">MList</a> t =&gt; (<a href="Data-Monoid-MList.html#t::::">:::</a> a t) <a href="Data-Monoid-MList.html#t::-62-:">:&gt;:</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:3">Monoid actions of heterogeneous lists
</h1><div class="doc"><p>Monoidal heterogeneous lists may act on one another as you would
 expect, with each element in the first list acting on each in the
 second.  Unfortunately, coding this up in type class instances is a
 bit fiddly.
</p></div><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:SM" class="def">SM</a> m <a href="src/Data-Monoid-MList.html#SM" class="link">Source</a></p><div class="doc"><p><code>SM</code>, an abbreviation for &quot;single monoid&quot; (as opposed to a
   heterogeneous list of monoids), is only used internally to help
   guide instance selection when defining the action of
   heterogeneous monoidal lists on each other.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:SM" class="def">SM</a> m</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:SM" class="caption collapser" onclick="toggleSection('i:SM')">Instances</p><div id="section.i:SM" class="show"><table><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> (<a href="Data-Monoid-MList.html#t:SM">SM</a> a) ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Monoid-Action.html#t:Action">Action</a> a a', <a href="Data-Monoid-Action.html#t:Action">Action</a> (<a href="Data-Monoid-MList.html#t:SM">SM</a> a) l) =&gt; <a href="Data-Monoid-Action.html#t:Action">Action</a> (<a href="Data-Monoid-MList.html#t:SM">SM</a> a) (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.11/doc/html/Data-Semigroup.html#t:Option">Option</a> a', l)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>