<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Diagrams.Core</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Diagrams-Core.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Diagrams-Core.html">Source</a></li><li><a href="http://www.haskell.org/haskellwiki/Diagrams/Comments/Diagrams.Core">User Comments</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">diagrams-core-0.7: Core libraries for diagrams EDSL</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Maintainer</th><td>diagrams-discuss@googlegroups.com</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Diagrams.Core</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Associated vector spaces
</a></li><li><a href="#g:2">Points
</a></li><li><a href="#g:3">Transformations
</a><ul><li><a href="#g:4">Invertible linear transformations
</a></li><li><a href="#g:5">General transformations
</a></li><li><a href="#g:6">Some specific transformations
</a></li><li><a href="#g:7">The Transformable class
</a></li><li><a href="#g:8">Translational invariance
</a></li></ul></li><li><a href="#g:9">Names
</a><ul><li><a href="#g:10">Subdiagram maps
</a></li></ul></li><li><a href="#g:11">Attributes and styles
</a></li><li><a href="#g:12">Envelopes
</a></li><li><a href="#g:13">Traces
</a></li><li><a href="#g:14">Things with local origins
</a></li><li><a href="#g:15">Juxtaposable things
</a></li><li><a href="#g:16">Queries
</a></li><li><a href="#g:17">Primtives
</a></li><li><a href="#g:18">Diagrams
</a><ul><li><a href="#g:19">Subdiagrams
</a></li></ul></li><li><a href="#g:20">Backends
</a><ul><li><a href="#g:21">The null backend
</a></li></ul></li><li><a href="#g:22">Convenience classes
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The core library of primitives forming the basis of an embedded
 domain-specific language for describing and rendering diagrams.
 Normal users of the diagrams library should almost never need to
 import anything from this package directly; instead, import modules
 (especially <a href="Diagrams-Prelude.html">Diagrams.Prelude</a>) from the diagrams-lib package,
 which re-exports most things of value to users.
</p><p>For most library code needing access to core internals, it should
 be sufficient to import this module, which simply re-exports useful
 functionality from other modules in the core library.  Library
 writers needing finer-grained access or functionality may
 occasionally find it useful to directly import one of the
 constituent core modules.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type family</span> <a href="#t:V">V</a> a :: *</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Point">Point</a> v</li><li class="src short"><a href="#v:origin">origin</a> :: <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AdditiveGroup.html#t:AdditiveGroup">AdditiveGroup</a> v =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v</li><li class="src short"><a href="#v:-42-.">(*.)</a> :: <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v</li><li class="src short"><span class="keyword">data</span>  u <a href="#t::-45-:">:-:</a> v</li><li class="src short"><a href="#v:-60--45--62-">(&lt;-&gt;)</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> u, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; (u -&gt; v) -&gt; (v -&gt; u) -&gt; u <a href="Diagrams-Core.html#t::-45-:">:-:</a> v</li><li class="src short"><a href="#v:linv">linv</a> ::  (u <a href="Diagrams-Core.html#t::-45-:">:-:</a> v) -&gt; v <a href="Diagrams-Core.html#t::-45-:">:-:</a> u</li><li class="src short"><a href="#v:lapp">lapp</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> u ~ <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> u) =&gt; (u <a href="Diagrams-Core.html#t::-45-:">:-:</a> v) -&gt; u -&gt; v</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Transformation">Transformation</a> v</li><li class="src short"><a href="#v:inv">inv</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v</li><li class="src short"><a href="#v:transp">transp</a> ::  <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; v <a href="Diagrams-Core.html#t::-45-:">:-:</a> v</li><li class="src short"><a href="#v:transl">transl</a> ::  <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; v</li><li class="src short"><a href="#v:apply">apply</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; v -&gt; v</li><li class="src short"><a href="#v:papply">papply</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v</li><li class="src short"><a href="#v:fromLinear">fromLinear</a> :: <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AdditiveGroup.html#t:AdditiveGroup">AdditiveGroup</a> v =&gt; (v <a href="Diagrams-Core.html#t::-45-:">:-:</a> v) -&gt; (v <a href="Diagrams-Core.html#t::-45-:">:-:</a> v) -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v</li><li class="src short"><a href="#v:translation">translation</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; v -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v</li><li class="src short"><a href="#v:translate">translate</a> :: (<a href="Diagrams-Core.html#t:Transformable">Transformable</a> t, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> (<a href="Diagrams-Core.html#t:V">V</a> t)) =&gt; <a href="Diagrams-Core.html#t:V">V</a> t -&gt; t -&gt; t</li><li class="src short"><a href="#v:moveTo">moveTo</a> :: <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> t =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> t) -&gt; t -&gt; t</li><li class="src short"><a href="#v:place">place</a> :: <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> t =&gt; t -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> t) -&gt; t</li><li class="src short"><a href="#v:scaling">scaling</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v</li><li class="src short"><a href="#v:scale">scale</a> :: (<a href="Diagrams-Core.html#t:Transformable">Transformable</a> t, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> t)), <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> t))) =&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> t) -&gt; t -&gt; t</li><li class="src short"><span class="keyword">class</span> <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> (<a href="Diagrams-Core.html#t:V">V</a> t) =&gt; <a href="#t:Transformable">Transformable</a> t  <span class="keyword">where</span><ul class="subs"><li><a href="#v:transform">transform</a> :: <a href="Diagrams-Core.html#t:Transformation">Transformation</a> (<a href="Diagrams-Core.html#t:V">V</a> t) -&gt; t -&gt; t</li></ul></li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:TransInv">TransInv</a> t = <a href="#v:TransInv">TransInv</a> {<ul class="subs"><li><a href="#v:unTransInv">unTransInv</a> :: t</li></ul>}</li><li class="src short"><span class="keyword">data</span>  <a href="#t:AName">AName</a> </li><li class="src short"><span class="keyword">data</span>  <a href="#t:Name">Name</a> </li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> a) =&gt; <a href="#t:IsName">IsName</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:toName">toName</a> :: a -&gt; <a href="Diagrams-Core.html#t:Name">Name</a></li></ul></li><li class="src short"><span class="keyword">class</span>  <a href="#t:Qualifiable">Qualifiable</a> q  <span class="keyword">where</span><ul class="subs"><li><a href="#v:-124--62-">(|&gt;)</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> a =&gt; a -&gt; q -&gt; q</li></ul></li><li class="src short"><a href="#v:.-62-">(.&gt;)</a> :: (<a href="Diagrams-Core.html#t:IsName">IsName</a> a1, <a href="Diagrams-Core.html#t:IsName">IsName</a> a2) =&gt; a1 -&gt; a2 -&gt; <a href="Diagrams-Core.html#t:Name">Name</a></li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:SubMap">SubMap</a> b v m = <a href="#v:SubMap">SubMap</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core.html#t:Name">Name</a> [<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m])</li><li class="src short"><a href="#v:fromNames">fromNames</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> a =&gt; [(a, <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m)] -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m</li><li class="src short"><a href="#v:rememberAs">rememberAs</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> a =&gt; a -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m</li><li class="src short"><a href="#v:lookupSub">lookupSub</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> n =&gt; n -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> [<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m]</li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> a, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> a) =&gt; <a href="#t:AttributeClass">AttributeClass</a> a </li><li class="src short"><span class="keyword">data</span>  <a href="#t:Attribute">Attribute</a> v</li><li class="src short"><a href="#v:mkAttr">mkAttr</a> :: <a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a =&gt; a -&gt; <a href="Diagrams-Core.html#t:Attribute">Attribute</a> v</li><li class="src short"><a href="#v:mkTAttr">mkTAttr</a> :: (<a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a, <a href="Diagrams-Core.html#t:Transformable">Transformable</a> a, <a href="Diagrams-Core.html#t:V">V</a> a ~ v) =&gt; a -&gt; <a href="Diagrams-Core.html#t:Attribute">Attribute</a> v</li><li class="src short"><a href="#v:unwrapAttr">unwrapAttr</a> :: <a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a =&gt; <a href="Diagrams-Core.html#t:Attribute">Attribute</a> v -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Style">Style</a> v</li><li class="src short"><span class="keyword">class</span>  <a href="#t:HasStyle">HasStyle</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:applyStyle">applyStyle</a> :: <a href="Diagrams-Core.html#t:Style">Style</a> (<a href="Diagrams-Core.html#t:V">V</a> a) -&gt; a -&gt; a</li></ul></li><li class="src short"><a href="#v:getAttr">getAttr</a> :: <span class="keyword">forall</span> a v. <a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a =&gt; <a href="Diagrams-Core.html#t:Style">Style</a> v -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:combineAttr">combineAttr</a> :: <a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a =&gt; a -&gt; <a href="Diagrams-Core.html#t:Style">Style</a> v -&gt; <a href="Diagrams-Core.html#t:Style">Style</a> v</li><li class="src short"><a href="#v:applyAttr">applyAttr</a> :: (<a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a, <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> d) =&gt; a -&gt; d -&gt; d</li><li class="src short"><a href="#v:applyTAttr">applyTAttr</a> :: (<a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a, <a href="Diagrams-Core.html#t:Transformable">Transformable</a> a, <a href="Diagrams-Core.html#t:V">V</a> a ~ <a href="Diagrams-Core.html#t:V">V</a> d, <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> d) =&gt; a -&gt; d -&gt; d</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Envelope">Envelope</a> v</li><li class="src short"><a href="#v:inEnvelope">inEnvelope</a> ::  (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Option">Option</a> (v -&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Max">Max</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Option">Option</a> (v -&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Max">Max</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v))) -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v</li><li class="src short"><a href="#v:appEnvelope">appEnvelope</a> ::  <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (v -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)</li><li class="src short"><a href="#v:onEnvelope">onEnvelope</a> ::  ((v -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) -&gt; v -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v</li><li class="src short"><a href="#v:mkEnvelope">mkEnvelope</a> ::  (v -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v</li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> (<a href="Diagrams-Core.html#t:V">V</a> a), <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> a))) =&gt; <a href="#t:Enveloped">Enveloped</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:getEnvelope">getEnvelope</a> :: a -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> (<a href="Diagrams-Core.html#t:V">V</a> a)</li></ul></li><li class="src short"><a href="#v:envelopeVMay">envelopeVMay</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:V">V</a> a)</li><li class="src short"><a href="#v:envelopeV">envelopeV</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="Diagrams-Core.html#t:V">V</a> a</li><li class="src short"><a href="#v:envelopePMay">envelopePMay</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a))</li><li class="src short"><a href="#v:envelopeP">envelopeP</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a)</li><li class="src short"><a href="#v:diameter">diameter</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> a)</li><li class="src short"><a href="#v:radius">radius</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> a)</li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:Trace">Trace</a> v = <a href="#v:Trace">Trace</a> {<ul class="subs"><li><a href="#v:appTrace">appTrace</a> :: <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)</li></ul>}</li><li class="src short"><a href="#v:inTrace">inTrace</a> ::  ((<a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v</li><li class="src short"><a href="#v:mkTrace">mkTrace</a> ::  (<a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v</li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> a)), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> (<a href="Diagrams-Core.html#t:V">V</a> a)) =&gt; <a href="#t:Traced">Traced</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:getTrace">getTrace</a> :: a -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> (<a href="Diagrams-Core.html#t:V">V</a> a)</li></ul></li><li class="src short"><a href="#v:traceV">traceV</a> :: <a href="Diagrams-Core.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:V">V</a> a)</li><li class="src short"><a href="#v:traceP">traceP</a> :: <a href="Diagrams-Core.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a))</li><li class="src short"><a href="#v:maxTraceV">maxTraceV</a> :: <a href="Diagrams-Core.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:V">V</a> a)</li><li class="src short"><a href="#v:maxTraceP">maxTraceP</a> :: <a href="Diagrams-Core.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a))</li><li class="src short"><span class="keyword">class</span> <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> (<a href="Diagrams-Core.html#t:V">V</a> t) =&gt; <a href="#t:HasOrigin">HasOrigin</a> t  <span class="keyword">where</span><ul class="subs"><li><a href="#v:moveOriginTo">moveOriginTo</a> :: <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> t) -&gt; t -&gt; t</li></ul></li><li class="src short"><a href="#v:moveOriginBy">moveOriginBy</a> :: <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> t =&gt; <a href="Diagrams-Core.html#t:V">V</a> t -&gt; t -&gt; t</li><li class="src short"><span class="keyword">class</span>  <a href="#t:Juxtaposable">Juxtaposable</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:juxtapose">juxtapose</a> :: <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; a -&gt; a</li></ul></li><li class="src short"><a href="#v:juxtaposeDefault">juxtaposeDefault</a> :: (<a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a, <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> a) =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; a -&gt; a</li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:Query">Query</a> v m = <a href="#v:Query">Query</a> {<ul class="subs"><li><a href="#v:runQuery">runQuery</a> :: <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; m</li></ul>}</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Prim">Prim</a> b v <span class="keyword">where</span><ul class="subs"><li><a href="#v:Prim">Prim</a> :: (<a href="Diagrams-Core.html#t:IsPrim">IsPrim</a> p, <a href="Diagrams-Core.html#t:Renderable">Renderable</a> p b) =&gt; p -&gt; <a href="Diagrams-Core.html#t:Prim">Prim</a> b (<a href="Diagrams-Core.html#t:V">V</a> p)  </li></ul></li><li class="src short"><span class="keyword">class</span> <a href="Diagrams-Core.html#t:Transformable">Transformable</a> p =&gt; <a href="#t:IsPrim">IsPrim</a> p  <span class="keyword">where</span><ul class="subs"><li><a href="#v:transformWithFreeze">transformWithFreeze</a> :: <a href="Diagrams-Core.html#t:Transformation">Transformation</a> (<a href="Diagrams-Core.html#t:V">V</a> p) -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> (<a href="Diagrams-Core.html#t:V">V</a> p) -&gt; p -&gt; p</li></ul></li><li class="src short"><a href="#v:nullPrim">nullPrim</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:Render">Render</a> b v)) =&gt; <a href="Diagrams-Core.html#t:Prim">Prim</a> b v</li><li class="src short"><span class="keyword">data</span>  <a href="#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:mkQD">mkQD</a> ::  <a href="Diagrams-Core.html#t:Prim">Prim</a> b v -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m -&gt; <a href="Diagrams-Core.html#t:Query">Query</a> v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><span class="keyword">type</span> <a href="#t:Diagram">Diagram</a> b v = <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a></li><li class="src short"><a href="#v:prims">prims</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; [(<a href="Diagrams-Core.html#t:Prim">Prim</a> b v, (<a href="Data-Monoid-Split.html#t:Split">Split</a> (<a href="Diagrams-Core.html#t:Transformation">Transformation</a> v), <a href="Diagrams-Core.html#t:Style">Style</a> v))]</li><li class="src short"><a href="#v:envelope">envelope</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v</li><li class="src short"><a href="#v:trace">trace</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v</li><li class="src short"><a href="#v:subMap">subMap</a> ::  <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m</li><li class="src short"><a href="#v:names">names</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; [(<a href="Diagrams-Core.html#t:Name">Name</a>, [<a href="Diagrams-Core.html#t:Point">Point</a> v])]</li><li class="src short"><a href="#v:query">query</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Query">Query</a> v m</li><li class="src short"><a href="#v:sample">sample</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; m</li><li class="src short"><a href="#v:value">value</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a> -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:resetValue">resetValue</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a></li><li class="src short"><a href="#v:clearValue">clearValue</a> ::  <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a></li><li class="src short"><a href="#v:nameSub">nameSub</a> :: (<a href="Diagrams-Core.html#t:IsName">IsName</a> n, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m) -&gt; n -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:withName">withName</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> n =&gt; n -&gt; (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:withNameAll">withNameAll</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> n =&gt; n -&gt; ([<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m] -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:withNames">withNames</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> n =&gt; [n] -&gt; ([<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m] -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:localize">localize</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:freeze">freeze</a> :: <span class="keyword">forall</span> v b m. (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:setEnvelope">setEnvelope</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:setTrace">setTrace</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:atop">atop</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Subdiagram">Subdiagram</a> b v m = <a href="#v:Subdiagram">Subdiagram</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v)</li><li class="src short"><a href="#v:mkSubdiagram">mkSubdiagram</a> ::  <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m</li><li class="src short"><a href="#v:getSub">getSub</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:rawSub">rawSub</a> ::  <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m</li><li class="src short"><a href="#v:location">location</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v</li><li class="src short"><a href="#v:subPoint">subPoint</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m</li><li class="src short"><span class="keyword">class</span> (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:Render">Render</a> b v)) =&gt; <a href="#t:Backend">Backend</a> b v  <span class="keyword">where</span><ul class="subs"><li><span class="keyword">data</span> <a href="#t:Render">Render</a> b v :: *</li><li><span class="keyword">type</span> <a href="#t:Result">Result</a> b v :: *</li><li><span class="keyword">data</span> <a href="#t:Options">Options</a> b v :: *</li><li><a href="#v:withStyle">withStyle</a> :: b -&gt; <a href="Diagrams-Core.html#t:Style">Style</a> v -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; <a href="Diagrams-Core.html#t:Render">Render</a> b v -&gt; <a href="Diagrams-Core.html#t:Render">Render</a> b v</li><li><a href="#v:doRender">doRender</a> :: b -&gt; <a href="Diagrams-Core.html#t:Options">Options</a> b v -&gt; <a href="Diagrams-Core.html#t:Render">Render</a> b v -&gt; <a href="Diagrams-Core.html#t:Result">Result</a> b v</li><li><a href="#v:adjustDia">adjustDia</a> :: <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m =&gt; b -&gt; <a href="Diagrams-Core.html#t:Options">Options</a> b v -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; (<a href="Diagrams-Core.html#t:Options">Options</a> b v, <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</li><li><a href="#v:renderDia">renderDia</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; b -&gt; <a href="Diagrams-Core.html#t:Options">Options</a> b v -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Result">Result</a> b v</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="Diagrams-Core.html#t:Backend">Backend</a> b v =&gt; <a href="#t:MultiBackend">MultiBackend</a> b v  <span class="keyword">where</span><ul class="subs"><li><a href="#v:renderDias">renderDias</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; b -&gt; <a href="Diagrams-Core.html#t:Options">Options</a> b v -&gt; [<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m] -&gt; <a href="Diagrams-Core.html#t:Result">Result</a> b v</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="Diagrams-Core.html#t:Transformable">Transformable</a> t =&gt; <a href="#t:Renderable">Renderable</a> t b  <span class="keyword">where</span><ul class="subs"><li><a href="#v:render">render</a> :: b -&gt; t -&gt; <a href="Diagrams-Core.html#t:Render">Render</a> b (<a href="Diagrams-Core.html#t:V">V</a> t)</li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:NullBackend">NullBackend</a> </li><li class="src short"><span class="keyword">type</span> <a href="#t:D">D</a> v = <a href="Diagrams-Core.html#t:Diagram">Diagram</a> <a href="Diagrams-Core.html#t:NullBackend">NullBackend</a> v</li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-Basis.html#t:HasBasis">HasBasis</a> v, <a href="http://hackage.haskell.org/packages/archive/MemoTrie/0.6.1/doc/html/Data-MemoTrie.html#t:HasTrie">HasTrie</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-Basis.html#t:Basis">Basis</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v) =&gt; <a href="#t:HasLinearMap">HasLinearMap</a> v </li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> s, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> s, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> s, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AdditiveGroup.html#t:AdditiveGroup">AdditiveGroup</a> s) =&gt; <a href="#t:OrderedField">OrderedField</a> s </li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="#t:Monoid-39-">Monoid'</a> m </li></ul></div><div id="interface"><h1 id="g:1">Associated vector spaces
</h1><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:V" class="def">V</a> a :: *<a href="src/Diagrams-Core-V.html#V" class="link">Source</a></p><div class="doc"><p>Many sorts of objects have an associated vector space in which
   they &quot;live&quot;.  The type function <code>V</code> maps from object types to
   the associated vector space.
</p></div></div><h1 id="g:2">Points
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Point" class="def">Point</a> v </p><div class="doc"><p><code>Point</code> is a newtype wrapper around vectors used to represent
   points, so we don't get them mixed up. The distinction between
   vectors and points is important: translations affect points, but
   leave vectors unchanged.  Points are instances of the
   <code><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AffineSpace.html#t:AffineSpace">AffineSpace</a></code> class from <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AffineSpace.html">Data.AffineSpace</a>.
</p></div><div class="subs instances"><p id="control.i:Point" class="caption collapser" onclick="toggleSection('i:Point')">Instances</p><div id="section.i:Point" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> <a href="Diagrams-Core.html#t:Point">Point</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable1">Typeable1</a> <a href="Diagrams-Core.html#t:Point">Point</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Data.html#t:Data">Data</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Data.html#t:Data">Data</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Read.html#t:Read">Read</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Read.html#t:Read">Read</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AdditiveGroup.html#t:AdditiveGroup">AdditiveGroup</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AffineSpace.html#t:AffineSpace">AffineSpace</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v) =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc"><p>The trace of a single point is the empty trace, <em>i.e.</em> the one
   which returns positive infinity for every query.  Arguably it
   should return a finite distance for vectors aimed directly at the
   given point and infinity for everything else, but due to
   floating-point inaccuracy this is problematic.  Note that the
   envelope for a single point is <em>not</em> the empty envelope (see
   <a href="Diagrams-Core-Envelope.html">Diagrams.Core.Envelope</a>).
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v) =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v) v</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:origin" class="def">origin</a> :: <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AdditiveGroup.html#t:AdditiveGroup">AdditiveGroup</a> v =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v</p><div class="doc"><p>The origin of the vector space <code>v</code>.
</p></div></div><div class="top"><p class="src"><a name="v:-42-." class="def">(*.)</a> :: <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v</p><div class="doc"><p>Scale a point by a scalar.
</p></div></div><h1 id="g:3">Transformations
</h1><h2 id="g:4">Invertible linear transformations
</h2><div class="top"><p class="src"><span class="keyword">data</span>  u <a name="t::-45-:" class="def">:-:</a> v <a href="src/Diagrams-Core-Transform.html#%3A-%3A" class="link">Source</a></p><div class="doc"><p><code>(v1 :-: v2)</code> is a linear map paired with its inverse.
</p></div><div class="subs instances"><p id="control.i::-45-:" class="caption collapser" onclick="toggleSection('i::-45-:')">Instances</p><div id="section.i::-45-:" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t::-45-:">:-:</a> v v)</td><td class="doc"><p>Invertible linear maps from a vector space to itself form a
   monoid under composition.
</p></td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core.html#t::-45-:">:-:</a> v v)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:-60--45--62-" class="def">(&lt;-&gt;)</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> u, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; (u -&gt; v) -&gt; (v -&gt; u) -&gt; u <a href="Diagrams-Core.html#t::-45-:">:-:</a> v<a href="src/Diagrams-Core-Transform.html#%3C-%3E" class="link">Source</a></p><div class="doc"><p>Create an invertible linear map from two functions which are
   assumed to be linear inverses.
</p></div></div><div class="top"><p class="src"><a name="v:linv" class="def">linv</a> ::  (u <a href="Diagrams-Core.html#t::-45-:">:-:</a> v) -&gt; v <a href="Diagrams-Core.html#t::-45-:">:-:</a> u<a href="src/Diagrams-Core-Transform.html#linv" class="link">Source</a></p><div class="doc"><p>Invert a linear map.
</p></div></div><div class="top"><p class="src"><a name="v:lapp" class="def">lapp</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> u ~ <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> u) =&gt; (u <a href="Diagrams-Core.html#t::-45-:">:-:</a> v) -&gt; u -&gt; v<a href="src/Diagrams-Core-Transform.html#lapp" class="link">Source</a></p><div class="doc"><p>Apply a linear map to a vector.
</p></div></div><h2 id="g:5">General transformations
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Transformation" class="def">Transformation</a> v <a href="src/Diagrams-Core-Transform.html#Transformation" class="link">Source</a></p><div class="doc"><p>General (affine) transformations, represented by an invertible
   linear map, its <em>transpose</em>, and a vector representing a
   translation component.
</p><p>By the <em>transpose</em> of a linear map we mean simply the linear map
   corresponding to the transpose of the map's matrix
   representation.  For example, any scale is its own transpose,
   since scales are represented by matrices with zeros everywhere
   except the diagonal.  The transpose of a rotation is the same as
   its inverse.
</p><p>The reason we need to keep track of transposes is because it
   turns out that when transforming a shape according to some linear
   map L, the shape's <em>normal vectors</em> transform according to L's
   inverse transpose.  This is exactly what we need when
   transforming bounding functions, which are defined in terms of
   <em>perpendicular</em> (i.e. normal) hyperplanes.
</p></div><div class="subs instances"><p id="control.i:Transformation" class="caption collapser" onclick="toggleSection('i:Transformation')">Instances</p><div id="section.i:Transformation" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:Transformation">Transformation</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core.html#t:Transformation">Transformation</a> v)</td><td class="doc"><p>Transformations are closed under composition; <code>t1 <a href=""></a> t2</code> is the
   transformation which performs first <code>t2</code>, then <code>t1</code>.
</p></td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Transformation">Transformation</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Transformation">Transformation</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, ~ * v (<a href="Diagrams-Core.html#t:V">V</a> a), <a href="Diagrams-Core.html#t:Transformable">Transformable</a> a) =&gt; <a href="Data-Monoid-Action.html#t:Action">Action</a> (<a href="Diagrams-Core.html#t:Transformation">Transformation</a> v) a</td><td class="doc"><p>Transformations can act on transformable things.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:inv" class="def">inv</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v<a href="src/Diagrams-Core-Transform.html#inv" class="link">Source</a></p><div class="doc"><p>Invert a transformation.
</p></div></div><div class="top"><p class="src"><a name="v:transp" class="def">transp</a> ::  <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; v <a href="Diagrams-Core.html#t::-45-:">:-:</a> v<a href="src/Diagrams-Core-Transform.html#transp" class="link">Source</a></p><div class="doc"><p>Get the transpose of a transformation (ignoring the translation
   component).
</p></div></div><div class="top"><p class="src"><a name="v:transl" class="def">transl</a> ::  <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; v<a href="src/Diagrams-Core-Transform.html#transl" class="link">Source</a></p><div class="doc"><p>Get the translational component of a transformation.
</p></div></div><div class="top"><p class="src"><a name="v:apply" class="def">apply</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; v -&gt; v<a href="src/Diagrams-Core-Transform.html#apply" class="link">Source</a></p><div class="doc"><p>Apply a transformation to a vector.  Note that any translational
   component of the transformation will not affect the vector, since
   vectors are invariant under translation.
</p></div></div><div class="top"><p class="src"><a name="v:papply" class="def">papply</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v<a href="src/Diagrams-Core-Transform.html#papply" class="link">Source</a></p><div class="doc"><p>Apply a transformation to a point.
</p></div></div><div class="top"><p class="src"><a name="v:fromLinear" class="def">fromLinear</a> :: <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AdditiveGroup.html#t:AdditiveGroup">AdditiveGroup</a> v =&gt; (v <a href="Diagrams-Core.html#t::-45-:">:-:</a> v) -&gt; (v <a href="Diagrams-Core.html#t::-45-:">:-:</a> v) -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v<a href="src/Diagrams-Core-Transform.html#fromLinear" class="link">Source</a></p><div class="doc"><p>Create a general affine transformation from an invertible linear
   transformation and its transpose.  The translational component is
   assumed to be zero.
</p></div></div><h2 id="g:6">Some specific transformations
</h2><div class="top"><p class="src"><a name="v:translation" class="def">translation</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; v -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v<a href="src/Diagrams-Core-Transform.html#translation" class="link">Source</a></p><div class="doc"><p>Create a translation.
</p></div></div><div class="top"><p class="src"><a name="v:translate" class="def">translate</a> :: (<a href="Diagrams-Core.html#t:Transformable">Transformable</a> t, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> (<a href="Diagrams-Core.html#t:V">V</a> t)) =&gt; <a href="Diagrams-Core.html#t:V">V</a> t -&gt; t -&gt; t<a href="src/Diagrams-Core-Transform.html#translate" class="link">Source</a></p><div class="doc"><p>Translate by a vector.
</p></div></div><div class="top"><p class="src"><a name="v:moveTo" class="def">moveTo</a> :: <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> t =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> t) -&gt; t -&gt; t<a href="src/Diagrams-Core-HasOrigin.html#moveTo" class="link">Source</a></p><div class="doc"><p>Translate the object by the translation that sends the origin to
   the given point. Note that this is dual to <code><a href="Diagrams-Core.html#v:moveOriginTo">moveOriginTo</a></code>, i.e. we
   should have
</p><pre> moveTo (origin .^+ v) === moveOriginTo (origin .^- v)
</pre><p>For types which are also <code>Transformable</code>, this is essentially the
   same as <code>translate</code>, i.e.
</p><pre> moveTo (origin .^+ v) === translate v
</pre></div></div><div class="top"><p class="src"><a name="v:place" class="def">place</a> :: <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> t =&gt; t -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> t) -&gt; t<a href="src/Diagrams-Core-HasOrigin.html#place" class="link">Source</a></p><div class="doc"><p>A flipped variant of <code><a href="Diagrams-Core.html#v:moveTo">moveTo</a></code>, provided for convenience.  Useful
   when writing a function which takes a point as an argument, such
   as when using <code>withName</code> and friends.
</p></div></div><div class="top"><p class="src"><a name="v:scaling" class="def">scaling</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v<a href="src/Diagrams-Core-Transform.html#scaling" class="link">Source</a></p><div class="doc"><p>Create a uniform scaling transformation.
</p></div></div><div class="top"><p class="src"><a name="v:scale" class="def">scale</a> :: (<a href="Diagrams-Core.html#t:Transformable">Transformable</a> t, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> t)), <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> t))) =&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> t) -&gt; t -&gt; t<a href="src/Diagrams-Core-Transform.html#scale" class="link">Source</a></p><div class="doc"><p>Scale uniformly in every dimension by the given scalar.
</p></div></div><h2 id="g:7">The Transformable class
</h2><div class="top"><p class="src"><span class="keyword">class</span> <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> (<a href="Diagrams-Core.html#t:V">V</a> t) =&gt; <a name="t:Transformable" class="def">Transformable</a> t  <span class="keyword">where</span><a href="src/Diagrams-Core-Transform.html#Transformable" class="link">Source</a></p><div class="doc"><p>Type class for things <code>t</code> which can be transformed.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:transform" class="def">transform</a> :: <a href="Diagrams-Core.html#t:Transformation">Transformation</a> (<a href="Diagrams-Core.html#t:V">V</a> t) -&gt; t -&gt; t<a href="src/Diagrams-Core-Transform.html#transform" class="link">Source</a></p><div class="doc"><p>Apply a transformation to an object.
</p></div></div><div class="subs instances"><p id="control.i:Transformable" class="caption collapser" onclick="toggleSection('i:Transformable')">Instances</p><div id="section.i:Transformable" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:Transformable">Transformable</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Transformable">Transformable</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Rational">Rational</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Transformable">Transformable</a> t =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> [t]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:Transformable">Transformable</a> t, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> t) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Set.html#t:Set">Set</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Transformable">Transformable</a> m =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Data-Monoid-Deletable.html#t:Deletable">Deletable</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Transformable">Transformable</a> t =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Transformation">Transformation</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Style">Style</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Attribute">Attribute</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-Basis.html#t:HasBasis">HasBasis</a> (<a href="Diagrams-Core.html#t:V">V</a> b), <a href="http://hackage.haskell.org/packages/archive/MemoTrie/0.6.1/doc/html/Data-MemoTrie.html#t:HasTrie">HasTrie</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-Basis.html#t:Basis">Basis</a> (<a href="Diagrams-Core.html#t:V">V</a> b)), <a href="Diagrams-Core.html#t:Transformable">Transformable</a> a, <a href="Diagrams-Core.html#t:Transformable">Transformable</a> b, ~ * (<a href="Diagrams-Core.html#t:V">V</a> b) (<a href="Diagrams-Core.html#t:V">V</a> a)) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (a -&gt; b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:Transformable">Transformable</a> a, <a href="Diagrams-Core.html#t:Transformable">Transformable</a> b, ~ * (<a href="Diagrams-Core.html#t:V">V</a> a) (<a href="Diagrams-Core.html#t:V">V</a> b)) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Transformable">Transformable</a> t =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> k t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Query">Query</a> v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v)</td><td class="doc"><p>The <code><a href="Diagrams-Core.html#t:Transformable">Transformable</a></code> instance for <code><a href="Diagrams-Core.html#t:Prim">Prim</a></code> just pushes calls to
   <code><a href="Diagrams-Core.html#v:transform">transform</a></code> down through the <code><a href="Diagrams-Core.html#t:Prim">Prim</a></code> constructor.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:Transformable">Transformable</a> a, <a href="Diagrams-Core.html#t:Transformable">Transformable</a> b, <a href="Diagrams-Core.html#t:Transformable">Transformable</a> c, ~ * (<a href="Diagrams-Core.html#t:V">V</a> a) (<a href="Diagrams-Core.html#t:V">V</a> b), ~ * (<a href="Diagrams-Core.html#t:V">V</a> a) (<a href="Diagrams-Core.html#t:V">V</a> c)) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (a, b, c)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Diagrams can be transformed by transforming each of their
   components appropriately.
</p></td></tr></table></div></div></div><h2 id="g:8">Translational invariance
</h2><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:TransInv" class="def">TransInv</a> t <a href="src/Diagrams-Core-Transform.html#TransInv" class="link">Source</a></p><div class="doc"><p><code>TransInv</code> is a wrapper which makes a transformable type
   translationally invariant; the translational component of
   transformations will no longer affect things wrapped in
   <code>TransInv</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:TransInv" class="def">TransInv</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:unTransInv" class="def">unTransInv</a> :: t</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:TransInv" class="caption collapser" onclick="toggleSection('i:TransInv')">Instances</p><div id="section.i:TransInv" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> t =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> t =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> t =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> t =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> t =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> (<a href="Diagrams-Core.html#t:V">V</a> t) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Transformable">Transformable</a> t =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a> a =&gt; <a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Traced">Traced</a> t =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> t =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:9">Names
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:AName" class="def">AName</a>  <a href="src/Diagrams-Core-Names.html#AName" class="link">Source</a></p><div class="doc"><p>Atomic names.  <code>AName</code> is just an existential wrapper around
   things which are <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a></code>, <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a></code> and <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a></code>.
</p></div><div class="subs instances"><p id="control.i:AName" class="caption collapser" onclick="toggleSection('i:AName')">Instances</p><div id="section.i:AName" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Diagrams-Core.html#t:AName">AName</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Diagrams-Core.html#t:AName">AName</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> <a href="Diagrams-Core.html#t:AName">AName</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> <a href="Diagrams-Core.html#t:AName">AName</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="Diagrams-Core.html#t:AName">AName</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Name" class="def">Name</a>  <a href="src/Diagrams-Core-Names.html#Name" class="link">Source</a></p><div class="doc"><p>A (qualified) name is a (possibly empty) sequence of atomic names.
</p></div><div class="subs instances"><p id="control.i:Name" class="caption collapser" onclick="toggleSection('i:Name')">Instances</p><div id="section.i:Name" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Diagrams-Core.html#t:Name">Name</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Diagrams-Core.html#t:Name">Name</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> <a href="Diagrams-Core.html#t:Name">Name</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> <a href="Diagrams-Core.html#t:Name">Name</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> <a href="Diagrams-Core.html#t:Name">Name</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> <a href="Diagrams-Core.html#t:Name">Name</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a> <a href="Diagrams-Core.html#t:Name">Name</a></td><td class="doc"><p>Of course, names can be qualified using <code>(.&gt;)</code>.
</p></td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="Diagrams-Core.html#t:Name">Name</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core.html#t:Name">Name</a> a =&gt; <a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core.html#t:Name">Name</a> (<a href="Data-Monoid-Deletable.html#t:Deletable">Deletable</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core.html#t:Name">Name</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core.html#t:Name">Name</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core.html#t:Name">Name</a> (<a href="Diagrams-Core.html#t:Query">Query</a> v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core.html#t:Name">Name</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m)</td><td class="doc"><p>A name acts on a name map by qualifying every name in it.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m) (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core.html#t:Name">Name</a> [<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m])</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> a) =&gt; <a name="t:IsName" class="def">IsName</a> a  <span class="keyword">where</span><a href="src/Diagrams-Core-Names.html#IsName" class="link">Source</a></p><div class="doc"><p>Class for those types which can be used as names.  They must
   support <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a></code> (to facilitate extracting them from
   existential wrappers), <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a></code> (for comparison and efficient
   storage) and <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a></code>.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toName" class="def">toName</a> :: a -&gt; <a href="Diagrams-Core.html#t:Name">Name</a><a href="src/Diagrams-Core-Names.html#toName" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:IsName" class="caption collapser" onclick="toggleSection('i:IsName')">Instances</p><div id="section.i:IsName" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#t:Bool">Bool</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Char.html#t:Char">Char</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Double">Double</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Float">Float</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Int.html#t:Int">Int</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Integer">Integer</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="Diagrams-Core.html#t:Name">Name</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> <a href="Diagrams-Core.html#t:AName">AName</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:IsName">IsName</a> a =&gt; <a href="Diagrams-Core.html#t:IsName">IsName</a> [a]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:IsName">IsName</a> a, <a href="Diagrams-Core.html#t:IsName">IsName</a> b) =&gt; <a href="Diagrams-Core.html#t:IsName">IsName</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:IsName">IsName</a> a, <a href="Diagrams-Core.html#t:IsName">IsName</a> b, <a href="Diagrams-Core.html#t:IsName">IsName</a> c) =&gt; <a href="Diagrams-Core.html#t:IsName">IsName</a> (a, b, c)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:Qualifiable" class="def">Qualifiable</a> q  <span class="keyword">where</span><a href="src/Diagrams-Core-Names.html#Qualifiable" class="link">Source</a></p><div class="doc"><p>Instances of <code><a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a></code> are things which can be qualified by
   prefixing them with a name.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:-124--62-" class="def">(|&gt;)</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> a =&gt; a -&gt; q -&gt; q<a href="src/Diagrams-Core-Names.html#%7C%3E" class="link">Source</a></p><div class="doc"><p>Qualify with the given name.
</p></div></div><div class="subs instances"><p id="control.i:Qualifiable" class="caption collapser" onclick="toggleSection('i:Qualifiable')">Instances</p><div id="section.i:Qualifiable" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a> <a href="Diagrams-Core.html#t:Name">Name</a></td><td class="doc"><p>Of course, names can be qualified using <code>(.&gt;)</code>.
</p></td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a> a =&gt; <a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m)</td><td class="doc"><p><code><a href="Diagrams-Core.html#t:SubMap">SubMap</a></code>s are qualifiable: if <code>ns</code> is a <code><a href="Diagrams-Core.html#t:SubMap">SubMap</a></code>, then <code>a |&gt;
   ns</code> is the same <code><a href="Diagrams-Core.html#t:SubMap">SubMap</a></code> except with every name qualified by
   <code>a</code>.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Diagrams can be qualified so that all their named points can
   now be referred to using the qualification prefix.
</p></td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:.-62-" class="def">(.&gt;)</a> :: (<a href="Diagrams-Core.html#t:IsName">IsName</a> a1, <a href="Diagrams-Core.html#t:IsName">IsName</a> a2) =&gt; a1 -&gt; a2 -&gt; <a href="Diagrams-Core.html#t:Name">Name</a><a href="src/Diagrams-Core-Names.html#.%3E" class="link">Source</a></p><div class="doc"><p>Convenient operator for writing qualified names with atomic
   components of different types.  Instead of writing <code>toName a1 &lt;&gt;
   toName a2 &lt;&gt; toName a3</code> you can just write <code>a1 .&gt; a2 .&gt; a3</code>.
</p></div></div><h2 id="g:10">Subdiagram maps
</h2><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:SubMap" class="def">SubMap</a> b v m <a href="src/Diagrams-Core-Types.html#SubMap" class="link">Source</a></p><div class="doc"><p>A <code><a href="Diagrams-Core.html#t:SubMap">SubMap</a></code> is a map associating names to subdiagrams. There can
   be multiple associations for any given name.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:SubMap" class="def">SubMap</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core.html#t:Name">Name</a> [<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m])</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:SubMap" class="caption collapser" onclick="toggleSection('i:SubMap')">Instances</p><div id="section.i:SubMap" class="show"><table><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core.html#t:Name">Name</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m)</td><td class="doc"><p>A name acts on a name map by qualifying every name in it.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m)</td><td class="doc"><p><code><a href="Diagrams-Core.html#t:SubMap">SubMap</a></code>s form a monoid with the empty map as the identity, and
   map union as the binary operation.  No information is ever lost:
   if two maps have the same name in their domain, the resulting map
   will associate that name to the concatenation of the information
   associated with that name.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m)</td><td class="doc"><p><code><a href="Diagrams-Core.html#t:SubMap">SubMap</a></code>s are qualifiable: if <code>ns</code> is a <code><a href="Diagrams-Core.html#t:SubMap">SubMap</a></code>, then <code>a |&gt;
   ns</code> is the same <code><a href="Diagrams-Core.html#t:SubMap">SubMap</a></code> except with every name qualified by
   <code>a</code>.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m) (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core.html#t:Name">Name</a> [<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m])</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:fromNames" class="def">fromNames</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> a =&gt; [(a, <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m)] -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m<a href="src/Diagrams-Core-Types.html#fromNames" class="link">Source</a></p><div class="doc"><p>Construct a <code><a href="Diagrams-Core.html#t:SubMap">SubMap</a></code> from a list of associations between names
   and subdiagrams.
</p></div></div><div class="top"><p class="src"><a name="v:rememberAs" class="def">rememberAs</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> a =&gt; a -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m<a href="src/Diagrams-Core-Types.html#rememberAs" class="link">Source</a></p><div class="doc"><p>Add a name/diagram association to a submap.
</p></div></div><div class="top"><p class="src"><a name="v:lookupSub" class="def">lookupSub</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> n =&gt; n -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> [<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m]<a href="src/Diagrams-Core-Types.html#lookupSub" class="link">Source</a></p><div class="doc"><p>Look for the given name in a name map, returning a list of
   subdiagrams associated with that name.  If no names match the
   given name exactly, return all the subdiagrams associated with
   names of which the given name is a suffix.
</p></div></div><h1 id="g:11">Attributes and styles
</h1><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> a, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> a) =&gt; <a name="t:AttributeClass" class="def">AttributeClass</a> a <a href="src/Diagrams-Core-Style.html#AttributeClass" class="link">Source</a></p><div class="doc"><p>Every attribute must be an instance of <code>AttributeClass</code>, which
   simply guarantees <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a></code> and <code><a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a></code> constraints.  The
   <code><a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a></code> instance for an attribute determines how it will combine
   with other attributes of the same type.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Attribute" class="def">Attribute</a> v <a href="src/Diagrams-Core-Style.html#Attribute" class="link">Source</a></p><div class="doc"><p>An existential wrapper type to hold attributes.  Some attributes
   are affected by transformations and some are not.
</p></div><div class="subs instances"><p id="control.i:Attribute" class="caption collapser" onclick="toggleSection('i:Attribute')">Instances</p><div id="section.i:Attribute" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core.html#t:Attribute">Attribute</a> v)</td><td class="doc"><p>Attributes form a semigroup, where the semigroup operation simply
   returns the right-hand attribute when the types do not match, and
   otherwise uses the semigroup operation specific to the (matching)
   types.
</p></td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Attribute">Attribute</a> v)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:mkAttr" class="def">mkAttr</a> :: <a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a =&gt; a -&gt; <a href="Diagrams-Core.html#t:Attribute">Attribute</a> v<a href="src/Diagrams-Core-Style.html#mkAttr" class="link">Source</a></p><div class="doc"><p>Wrap up an attribute.
</p></div></div><div class="top"><p class="src"><a name="v:mkTAttr" class="def">mkTAttr</a> :: (<a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a, <a href="Diagrams-Core.html#t:Transformable">Transformable</a> a, <a href="Diagrams-Core.html#t:V">V</a> a ~ v) =&gt; a -&gt; <a href="Diagrams-Core.html#t:Attribute">Attribute</a> v<a href="src/Diagrams-Core-Style.html#mkTAttr" class="link">Source</a></p><div class="doc"><p>Wrap up a transformable attribute.
</p></div></div><div class="top"><p class="src"><a name="v:unwrapAttr" class="def">unwrapAttr</a> :: <a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a =&gt; <a href="Diagrams-Core.html#t:Attribute">Attribute</a> v -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a<a href="src/Diagrams-Core-Style.html#unwrapAttr" class="link">Source</a></p><div class="doc"><p>Unwrap an unknown <code><a href="Diagrams-Core.html#t:Attribute">Attribute</a></code> type, performing a dynamic (but
   safe) check on the type of the result.  If the required type
   matches the type of the attribute, the attribute value is
   returned wrapped in <code>Just</code>; if the types do not match, <code>Nothing</code>
   is returned.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Style" class="def">Style</a> v <a href="src/Diagrams-Core-Style.html#Style" class="link">Source</a></p><div class="doc"><p>A <code>Style</code> is a heterogeneous collection of attributes, containing
   at most one attribute of any given type.
</p></div><div class="subs instances"><p id="control.i:Style" class="caption collapser" onclick="toggleSection('i:Style')">Instances</p><div id="section.i:Style" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:Style">Style</a> v)</td><td class="doc"><p>The empty style contains no attributes; composition of styles is
   a union of attributes; if the two styles have attributes of the
   same type they are combined according to their semigroup
   structure.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core.html#t:Style">Style</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Style">Style</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> (<a href="Diagrams-Core.html#t:Style">Style</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> (<a href="Diagrams-Core.html#t:Style">Style</a> v) m</td><td class="doc"><p>Styles have no action on other monoids.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:HasStyle" class="def">HasStyle</a> a  <span class="keyword">where</span><a href="src/Diagrams-Core-Style.html#HasStyle" class="link">Source</a></p><div class="doc"><p>Type class for things which have a style.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:applyStyle" class="def">applyStyle</a> :: <a href="Diagrams-Core.html#t:Style">Style</a> (<a href="Diagrams-Core.html#t:V">V</a> a) -&gt; a -&gt; a<a href="src/Diagrams-Core-Style.html#applyStyle" class="link">Source</a></p><div class="doc"><p><em>Apply</em> a style by combining it (on the left) with the
   existing style.
</p></div></div><div class="subs instances"><p id="control.i:HasStyle" class="caption collapser" onclick="toggleSection('i:HasStyle')">Instances</p><div id="section.i:HasStyle" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> a =&gt; <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> [a]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> a) =&gt; <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Set.html#t:Set">Set</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> (<a href="Diagrams-Core.html#t:Style">Style</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> b =&gt; <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> (a -&gt; b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> a, <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> b, ~ * (<a href="Diagrams-Core.html#t:V">V</a> a) (<a href="Diagrams-Core.html#t:V">V</a> b)) =&gt; <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> a =&gt; <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> k a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:getAttr" class="def">getAttr</a> :: <span class="keyword">forall</span> a v. <a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a =&gt; <a href="Diagrams-Core.html#t:Style">Style</a> v -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a<a href="src/Diagrams-Core-Style.html#getAttr" class="link">Source</a></p><div class="doc"><p>Extract an attribute from a style of a particular type.  If the
   style contains an attribute of the requested type, it will be
   returned wrapped in <code>Just</code>; otherwise, <code>Nothing</code> is returned.
</p></div></div><div class="top"><p class="src"><a name="v:combineAttr" class="def">combineAttr</a> :: <a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a =&gt; a -&gt; <a href="Diagrams-Core.html#t:Style">Style</a> v -&gt; <a href="Diagrams-Core.html#t:Style">Style</a> v<a href="src/Diagrams-Core-Style.html#combineAttr" class="link">Source</a></p><div class="doc"><p>Add a new attribute to a style that does not already contain an
   attribute of this type, or combine it on the left with an existing
   attribute.
</p></div></div><div class="top"><p class="src"><a name="v:applyAttr" class="def">applyAttr</a> :: (<a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a, <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> d) =&gt; a -&gt; d -&gt; d<a href="src/Diagrams-Core-Style.html#applyAttr" class="link">Source</a></p><div class="doc"><p>Apply an attribute to an instance of <code><a href="Diagrams-Core.html#t:HasStyle">HasStyle</a></code> (such as a
   diagram or a style).  If the object already has an attribute of
   the same type, the new attribute is combined on the left with the
   existing attribute, according to their semigroup structure.
</p></div></div><div class="top"><p class="src"><a name="v:applyTAttr" class="def">applyTAttr</a> :: (<a href="Diagrams-Core.html#t:AttributeClass">AttributeClass</a> a, <a href="Diagrams-Core.html#t:Transformable">Transformable</a> a, <a href="Diagrams-Core.html#t:V">V</a> a ~ <a href="Diagrams-Core.html#t:V">V</a> d, <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> d) =&gt; a -&gt; d -&gt; d<a href="src/Diagrams-Core-Style.html#applyTAttr" class="link">Source</a></p><div class="doc"><p>Apply a transformable attribute to an instance of <code><a href="Diagrams-Core.html#t:HasStyle">HasStyle</a></code>
   (such as a diagram or a style).  If the object already has an
   attribute of the same type, the new attribute is combined on the
   left with the existing attribute, according to their semigroup
   structure.
</p></div></div><h1 id="g:12">Envelopes
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Envelope" class="def">Envelope</a> v <a href="src/Diagrams-Core-Envelope.html#Envelope" class="link">Source</a></p><div class="doc"><p>Every diagram comes equipped with an <em>envelope</em>.  What is an envelope?
</p><p>Consider first the idea of a <em>bounding box</em>. A bounding box
   expresses the distance to a bounding plane in every direction
   parallel to an axis.  That is, a bounding box can be thought of
   as the intersection of a collection of half-planes, two
   perpendicular to each axis.
</p><p>More generally, the intersection of half-planes in <em>every</em>
   direction would give a tight &quot;bounding region&quot;, or convex hull.
   However, representing such a thing intensionally would be
   impossible; hence bounding boxes are often used as an
   approximation.
</p><p>An envelope is an <em>extensional</em> representation of such a
   &quot;bounding region&quot;.  Instead of storing some sort of direct
   representation, we store a <em>function</em> which takes a direction as
   input and gives a distance to a bounding half-plane as output.
   The important point is that envelopes can be composed, and
   transformed by any affine transformation.
</p><p>Formally, given a vector <code>v</code>, the envelope computes a scalar <code>s</code> such
   that
</p><ul><li> for every point <code>u</code> inside the diagram,
       if the projection of <code>(u - origin)</code> onto <code>v</code> is <code>s' *^ v</code>, then <code>s' &lt;= s</code>.
</li><li> <code>s</code> is the smallest such scalar.
</li></ul><p>There is also a special &quot;empty envelope&quot;.
</p><p>The idea for envelopes came from
   Sebastian Setzer; see
   <a href="http://byorgey.wordpress.com/2009/10/28/collecting-attributes/#comment-2030">http://byorgey.wordpress.com/2009/10/28/collecting-attributes/#comment-2030</a>.  See also Brent Yorgey, <em>Monoids: Theme and Variations</em>, published in the 2012 Haskell Symposium: <a href="http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf">http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf</a>; video: <a href="http://www.youtube.com/watch?v=X-8NCkD2vOw">http://www.youtube.com/watch?v=X-8NCkD2vOw</a>.
</p></div><div class="subs instances"><p id="control.i:Envelope" class="caption collapser" onclick="toggleSection('i:Envelope')">Instances</p><div id="section.i:Envelope" class="show"><table><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core.html#t:Name">Name</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc"><p>The local origin of an envelope is the point with respect to
   which bounding queries are made, <em>i.e.</em> the point from which the
   input vectors are taken to originate.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Juxtaposable">Juxtaposable</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:inEnvelope" class="def">inEnvelope</a> ::  (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Option">Option</a> (v -&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Max">Max</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Option">Option</a> (v -&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Max">Max</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v))) -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v<a href="src/Diagrams-Core-Envelope.html#inEnvelope" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:appEnvelope" class="def">appEnvelope</a> ::  <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (v -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)<a href="src/Diagrams-Core-Envelope.html#appEnvelope" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:onEnvelope" class="def">onEnvelope</a> ::  ((v -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) -&gt; v -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v<a href="src/Diagrams-Core-Envelope.html#onEnvelope" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:mkEnvelope" class="def">mkEnvelope</a> ::  (v -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v<a href="src/Diagrams-Core-Envelope.html#mkEnvelope" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> (<a href="Diagrams-Core.html#t:V">V</a> a), <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> a))) =&gt; <a name="t:Enveloped" class="def">Enveloped</a> a  <span class="keyword">where</span><a href="src/Diagrams-Core-Envelope.html#Enveloped" class="link">Source</a></p><div class="doc"><p><code>Enveloped</code> abstracts over things which have an envelope.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:getEnvelope" class="def">getEnvelope</a> :: a -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> (<a href="Diagrams-Core.html#t:V">V</a> a)<a href="src/Diagrams-Core-Envelope.html#getEnvelope" class="link">Source</a></p><div class="doc"><p>Compute the envelope of an object.  For types with an intrinsic
   notion of &quot;local origin&quot;, the envelope will be based there.
   Other types (e.g. <code>Trail</code>) may have some other default
   reference point at which the envelope will be based; their
   instances should document what it is.
</p></div></div><div class="subs instances"><p id="control.i:Enveloped" class="caption collapser" onclick="toggleSection('i:Enveloped')">Instances</p><div id="section.i:Enveloped" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> b =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> [b]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> b =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Set.html#t:Set">Set</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v) =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> t =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a, <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> b, ~ * (<a href="Diagrams-Core.html#t:V">V</a> a) (<a href="Diagrams-Core.html#t:V">V</a> b)) =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> b =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> k b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:envelopeVMay" class="def">envelopeVMay</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:V">V</a> a)<a href="src/Diagrams-Core-Envelope.html#envelopeVMay" class="link">Source</a></p><div class="doc"><p>Compute the vector from the local origin to a separating
   hyperplane in the given direction, or <code>Nothing</code> for the empty
   envelope.
</p></div></div><div class="top"><p class="src"><a name="v:envelopeV" class="def">envelopeV</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="Diagrams-Core.html#t:V">V</a> a<a href="src/Diagrams-Core-Envelope.html#envelopeV" class="link">Source</a></p><div class="doc"><p>Compute the vector from the local origin to a separating
   hyperplane in the given direction.  Returns the zero vector for
   the empty envelope.
</p></div></div><div class="top"><p class="src"><a name="v:envelopePMay" class="def">envelopePMay</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a))<a href="src/Diagrams-Core-Envelope.html#envelopePMay" class="link">Source</a></p><div class="doc"><p>Compute the point on a separating hyperplane in the given
   direction, or <code>Nothing</code> for the empty envelope.
</p></div></div><div class="top"><p class="src"><a name="v:envelopeP" class="def">envelopeP</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a)<a href="src/Diagrams-Core-Envelope.html#envelopeP" class="link">Source</a></p><div class="doc"><p>Compute the point on a separating hyperplane in the given
   direction.  Returns the origin for the empty envelope.
</p></div></div><div class="top"><p class="src"><a name="v:diameter" class="def">diameter</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> a)<a href="src/Diagrams-Core-Envelope.html#diameter" class="link">Source</a></p><div class="doc"><p>Compute the diameter of a enveloped object along a particular
   vector.  Returns zero for the empty envelope.
</p></div></div><div class="top"><p class="src"><a name="v:radius" class="def">radius</a> :: <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> a)<a href="src/Diagrams-Core-Envelope.html#radius" class="link">Source</a></p><div class="doc"><p>Compute the &quot;radius&quot; (1/2 the diameter) of an enveloped object
   along a particular vector.
</p></div></div><h1 id="g:13">Traces
</h1><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:Trace" class="def">Trace</a> v <a href="src/Diagrams-Core-Trace.html#Trace" class="link">Source</a></p><div class="doc"><p>Every diagram comes equipped with a <em>trace</em>.  Intuitively, the
   trace for a diagram is like a raytracer: given a line
   (represented as a base point and a direction), the trace computes
   the distance from the base point along the line to the first
   intersection with the diagram.  The distance can be negative if
   the intersection is in the opposite direction from the base
   point, or infinite if the ray never intersects the diagram.
   Note: to obtain the distance to the <em>furthest</em> intersection
   instead of the <em>closest</em>, just negate the direction vector and
   then negate the result.
</p><p>Note that the output should actually be interpreted not as an
   absolute distance, but as a multiplier relative to the input
   vector.  That is, if the input vector is <code>v</code> and the returned
   scalar is <code>s</code>, the distance from the base point to the
   intersection is given by <code>s * magnitude v</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Trace" class="def">Trace</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:appTrace" class="def">appTrace</a> :: <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Trace" class="caption collapser" onclick="toggleSection('i:Trace')">Instances</p><div id="section.i:Trace" class="show"><table><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core.html#t:Name">Name</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v) =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:inTrace" class="def">inTrace</a> ::  ((<a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v<a href="src/Diagrams-Core-Trace.html#inTrace" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:mkTrace" class="def">mkTrace</a> ::  (<a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v<a href="src/Diagrams-Core-Trace.html#mkTrace" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core.html#t:V">V</a> a)), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> (<a href="Diagrams-Core.html#t:V">V</a> a)) =&gt; <a name="t:Traced" class="def">Traced</a> a  <span class="keyword">where</span><a href="src/Diagrams-Core-Trace.html#Traced" class="link">Source</a></p><div class="doc"><p><code>Traced</code> abstracts over things which have a trace.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:getTrace" class="def">getTrace</a> :: a -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> (<a href="Diagrams-Core.html#t:V">V</a> a)<a href="src/Diagrams-Core-Trace.html#getTrace" class="link">Source</a></p><div class="doc"><p>Compute the trace of an object.
</p></div></div><div class="subs instances"><p id="control.i:Traced" class="caption collapser" onclick="toggleSection('i:Traced')">Instances</p><div id="section.i:Traced" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:Traced">Traced</a> b =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> [b]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Traced">Traced</a> b =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Set.html#t:Set">Set</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v) =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc"><p>The trace of a single point is the empty trace, <em>i.e.</em> the one
   which returns positive infinity for every query.  Arguably it
   should return a finite distance for vectors aimed directly at the
   given point and infinity for everything else, but due to
   floating-point inaccuracy this is problematic.  Note that the
   envelope for a single point is <em>not</em> the empty envelope (see
   <a href="Diagrams-Core-Envelope.html">Diagrams.Core.Envelope</a>).
</p></td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Traced">Traced</a> t =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v) =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:Traced">Traced</a> a, <a href="Diagrams-Core.html#t:Traced">Traced</a> b, ~ * (<a href="Diagrams-Core.html#t:V">V</a> a) (<a href="Diagrams-Core.html#t:V">V</a> b)) =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:Traced">Traced</a> b =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> k b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:traceV" class="def">traceV</a> :: <a href="Diagrams-Core.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:V">V</a> a)<a href="src/Diagrams-Core-Trace.html#traceV" class="link">Source</a></p><div class="doc"><p>Compute the vector from the given point to the boundary of the
   given object in the given direction, or <code>Nothing</code> if there is no
   intersection.
</p></div></div><div class="top"><p class="src"><a name="v:traceP" class="def">traceP</a> :: <a href="Diagrams-Core.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a))<a href="src/Diagrams-Core-Trace.html#traceP" class="link">Source</a></p><div class="doc"><p>Given a base point and direction, compute the closest point on
   the boundary of the given object, or <code>Nothing</code> if there is no
   intersection in the given direction.
</p></div></div><div class="top"><p class="src"><a name="v:maxTraceV" class="def">maxTraceV</a> :: <a href="Diagrams-Core.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:V">V</a> a)<a href="src/Diagrams-Core-Trace.html#maxTraceV" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Diagrams-Core.html#v:traceV">traceV</a></code>, but computes a vector to the *furthest* point on
   the boundary instead of the closest.
</p></div></div><div class="top"><p class="src"><a name="v:maxTraceP" class="def">maxTraceP</a> :: <a href="Diagrams-Core.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> a))<a href="src/Diagrams-Core-Trace.html#maxTraceP" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Diagrams-Core.html#v:traceP">traceP</a></code>, but computes the *furthest* point on the boundary
   instead of the closest.
</p></div></div><h1 id="g:14">Things with local origins
</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> (<a href="Diagrams-Core.html#t:V">V</a> t) =&gt; <a name="t:HasOrigin" class="def">HasOrigin</a> t  <span class="keyword">where</span><a href="src/Diagrams-Core-HasOrigin.html#HasOrigin" class="link">Source</a></p><div class="doc"><p>Class of types which have an intrinsic notion of a &quot;local
   origin&quot;, i.e. things which are not invariant under translation,
   and which allow the origin to be moved.
</p><p>One might wonder why not just use <code>Transformable</code> instead of
   having a separate class for <code><a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a></code>; indeed, for types which
   are instances of both we should have the identity
</p><pre> moveOriginTo (origin .^+ v) === translate (negateV v)
</pre><p>The reason is that some things (e.g. vectors, <code>Trail</code>s) are
   transformable but are translationally invariant, i.e. have no
   origin.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:moveOriginTo" class="def">moveOriginTo</a> :: <a href="Diagrams-Core.html#t:Point">Point</a> (<a href="Diagrams-Core.html#t:V">V</a> t) -&gt; t -&gt; t<a href="src/Diagrams-Core-HasOrigin.html#moveOriginTo" class="link">Source</a></p><div class="doc"><p>Move the local origin to another point.
</p><p>Note that this function is in some sense dual to <code>translate</code>
   (for types which are also <code>Transformable</code>); moving the origin
   itself while leaving the object &quot;fixed&quot; is dual to fixing the
   origin and translating the diagram.
</p></div></div><div class="subs instances"><p id="control.i:HasOrigin" class="caption collapser" onclick="toggleSection('i:HasOrigin')">Instances</p><div id="section.i:HasOrigin" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> a =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> [a]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> a) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Set.html#t:Set">Set</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Point">Point</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> (<a href="Diagrams-Core.html#t:V">V</a> t) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Transformation">Transformation</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc"><p>The local origin of an envelope is the point with respect to
   which bounding queries are made, <em>i.e.</em> the point from which the
   input vectors are taken to originate.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> a, <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> b, ~ * (<a href="Diagrams-Core.html#t:V">V</a> a) (<a href="Diagrams-Core.html#t:V">V</a> b)) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> a =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> k a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Query">Query</a> v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Every diagram has an intrinsic &quot;local origin&quot; which is the
   basis for all combining operations.
</p></td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:moveOriginBy" class="def">moveOriginBy</a> :: <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> t =&gt; <a href="Diagrams-Core.html#t:V">V</a> t -&gt; t -&gt; t<a href="src/Diagrams-Core-HasOrigin.html#moveOriginBy" class="link">Source</a></p><div class="doc"><p>Move the local origin by a relative vector.
</p></div></div><h1 id="g:15">Juxtaposable things
</h1><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:Juxtaposable" class="def">Juxtaposable</a> a  <span class="keyword">where</span><a href="src/Diagrams-Core-Juxtapose.html#Juxtaposable" class="link">Source</a></p><div class="doc"><p>Class of things which can be placed &quot;next to&quot; other things, for some
   appropriate notion of &quot;next to&quot;.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:juxtapose" class="def">juxtapose</a> :: <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; a -&gt; a<a href="src/Diagrams-Core-Juxtapose.html#juxtapose" class="link">Source</a></p><div class="doc"><p><code>juxtapose v a1 a2</code> positions <code>a2</code> next to <code>a1</code> in the
   direction of <code>v</code>.  In particular, place <code>a2</code> so that <code>v</code> points
   from the local origin of <code>a1</code> towards the old local origin of
   <code>a2</code>; <code>a1</code>'s local origin becomes <code>a2</code>'s new local origin.  The
   result is just a translated version of <code>a2</code>.  (In particular,
   this operation does not <em>combine</em> <code>a1</code> and <code>a2</code> in any way.)
</p></div></div><div class="subs instances"><p id="control.i:Juxtaposable" class="caption collapser" onclick="toggleSection('i:Juxtaposable')">Instances</p><div id="section.i:Juxtaposable" class="show"><table><tr><td class="src">(<a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> b, <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> b) =&gt; <a href="Diagrams-Core.html#t:Juxtaposable">Juxtaposable</a> [b]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> b, <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> b, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> b) =&gt; <a href="Diagrams-Core.html#t:Juxtaposable">Juxtaposable</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Set.html#t:Set">Set</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Juxtaposable">Juxtaposable</a> (<a href="Diagrams-Core.html#t:Envelope">Envelope</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a, <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> a, <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> b, <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> b, ~ * (<a href="Diagrams-Core.html#t:V">V</a> a) (<a href="Diagrams-Core.html#t:V">V</a> b)) =&gt; <a href="Diagrams-Core.html#t:Juxtaposable">Juxtaposable</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> b, <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> b) =&gt; <a href="Diagrams-Core.html#t:Juxtaposable">Juxtaposable</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> k b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Juxtaposable">Juxtaposable</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:juxtaposeDefault" class="def">juxtaposeDefault</a> :: (<a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> a, <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> a) =&gt; <a href="Diagrams-Core.html#t:V">V</a> a -&gt; a -&gt; a -&gt; a<a href="src/Diagrams-Core-Juxtapose.html#juxtaposeDefault" class="link">Source</a></p><div class="doc"><p>Default implementation of <code><a href="Diagrams-Core.html#v:juxtapose">juxtapose</a></code> for things which are
   instances of <code><a href="Diagrams-Core.html#t:Enveloped">Enveloped</a></code> and <code><a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a></code>.  If either envelope is
   empty, the second object is returned unchanged.
</p></div></div><h1 id="g:16">Queries
</h1><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:Query" class="def">Query</a> v m <a href="src/Diagrams-Core-Query.html#Query" class="link">Source</a></p><div class="doc"><p>A query is a function that maps points in a vector space to
   values in some monoid. Queries naturally form a monoid, with
   two queries being combined pointwise.
</p><p>The idea for annotating diagrams with monoidal queries came from
   the graphics-drawingcombinators package, <a href="http://hackage.haskell.org/package/graphics-drawingcombinators">http://hackage.haskell.org/package/graphics-drawingcombinators</a>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Query" class="def">Query</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:runQuery" class="def">runQuery</a> :: <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; m</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Query" class="caption collapser" onclick="toggleSection('i:Query')">Instances</p><div id="section.i:Query" class="show"><table><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core.html#t:Name">Name</a> (<a href="Diagrams-Core.html#t:Query">Query</a> v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> (<a href="Diagrams-Core.html#t:Query">Query</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Diagrams-Core.html#t:Query">Query</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:Query">Query</a> v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core.html#t:Query">Query</a> v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Query">Query</a> v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Query">Query</a> v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:17">Primtives
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Prim" class="def">Prim</a> b v <span class="keyword">where</span><a href="src/Diagrams-Core-Types.html#Prim" class="link">Source</a></p><div class="doc"><p>A value of type <code>Prim b v</code> is an opaque (existentially quantified)
   primitive which backend <code>b</code> knows how to render in vector space <code>v</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Prim" class="def">Prim</a> :: (<a href="Diagrams-Core.html#t:IsPrim">IsPrim</a> p, <a href="Diagrams-Core.html#t:Renderable">Renderable</a> p b) =&gt; p -&gt; <a href="Diagrams-Core.html#t:Prim">Prim</a> b (<a href="Diagrams-Core.html#t:V">V</a> p)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Prim" class="caption collapser" onclick="toggleSection('i:Prim')">Instances</p><div id="section.i:Prim" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v)</td><td class="doc"><p>The <code><a href="Diagrams-Core.html#t:Transformable">Transformable</a></code> instance for <code><a href="Diagrams-Core.html#t:Prim">Prim</a></code> just pushes calls to
   <code><a href="Diagrams-Core.html#v:transform">transform</a></code> down through the <code><a href="Diagrams-Core.html#t:Prim">Prim</a></code> constructor.
</p></td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:IsPrim">IsPrim</a> (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Renderable">Renderable</a> (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v) b</td><td class="doc"><p>The <code><a href="Diagrams-Core.html#t:Renderable">Renderable</a></code> instance for <code><a href="Diagrams-Core.html#t:Prim">Prim</a></code> just pushes calls to
   <code><a href="Diagrams-Core.html#v:render">render</a></code> down through the <code><a href="Diagrams-Core.html#t:Prim">Prim</a></code> constructor.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="Diagrams-Core.html#t:Transformable">Transformable</a> p =&gt; <a name="t:IsPrim" class="def">IsPrim</a> p  <span class="keyword">where</span><a href="src/Diagrams-Core-Types.html#IsPrim" class="link">Source</a></p><div class="doc"><p>A type class for primitive things which know how to handle being
   transformed by both a normal transformation and a &quot;frozen&quot;
   transformation.  The default implementation simply applies both.
   At the moment, <code>ScaleInv</code> is the only type with a non-default
   instance of <code><a href="Diagrams-Core.html#t:IsPrim">IsPrim</a></code>.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:transformWithFreeze" class="def">transformWithFreeze</a> :: <a href="Diagrams-Core.html#t:Transformation">Transformation</a> (<a href="Diagrams-Core.html#t:V">V</a> p) -&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> (<a href="Diagrams-Core.html#t:V">V</a> p) -&gt; p -&gt; p<a href="src/Diagrams-Core-Types.html#transformWithFreeze" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:IsPrim" class="caption collapser" onclick="toggleSection('i:IsPrim')">Instances</p><div id="section.i:IsPrim" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:IsPrim">IsPrim</a> (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:nullPrim" class="def">nullPrim</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:Render">Render</a> b v)) =&gt; <a href="Diagrams-Core.html#t:Prim">Prim</a> b v<a href="src/Diagrams-Core-Types.html#nullPrim" class="link">Source</a></p><div class="doc"><p>The null primitive, which every backend can render by doing
   nothing.
</p></div></div><h1 id="g:18">Diagrams
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:QDiagram" class="def">QDiagram</a> b v m <a href="src/Diagrams-Core-Types.html#QDiagram" class="link">Source</a></p><div class="doc"><p>The fundamental diagram type is represented by trees of
   primitives with various monoidal annotations.  The <code>Q</code> in
   <code>QDiagram</code> stands for &quot;Queriable&quot;, as distinguished from
   <code><a href="Diagrams-Core.html#t:Diagram">Diagram</a></code>, a synonym for <code>QDiagram</code> with the query type
   specialized to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a></code>.
</p></div><div class="subs instances"><p id="control.i:QDiagram" class="caption collapser" onclick="toggleSection('i:QDiagram')">Instances</p><div id="section.i:QDiagram" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable3">Typeable3</a> <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Diagrams form a monoid since each of their components do: the
   empty diagram has no primitives, an empty envelope, an empty
   trace, no named subdiagrams, and a constantly empty query
   function.
</p><p>Diagrams compose by aligning their respective local origins.  The
   new diagram has all the primitives and all the names from the two
   diagrams combined, and query functions are combined pointwise.
   The first diagram goes on top of the second.  &quot;On top of&quot;
   probably only makes sense in vector spaces of dimension lower
   than 3, but in theory it could make sense for, say, 3-dimensional
   diagrams when viewed by 4-dimensional beings.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Every diagram has an intrinsic &quot;local origin&quot; which is the
   basis for all combining operations.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Diagrams can be transformed by transforming each of their
   components appropriately.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Qualifiable">Qualifiable</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc"><p>Diagrams can be qualified so that all their named points can
   now be referred to using the qualification prefix.
</p></td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:HasStyle">HasStyle</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Juxtaposable">Juxtaposable</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:mkQD" class="def">mkQD</a> ::  <a href="Diagrams-Core.html#t:Prim">Prim</a> b v -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m -&gt; <a href="Diagrams-Core.html#t:Query">Query</a> v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#mkQD" class="link">Source</a></p><div class="doc"><p>Create a diagram from a single primitive, along with an envelope,
   trace, subdiagram map, and query function.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Diagram" class="def">Diagram</a> b v = <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a><a href="src/Diagrams-Core-Types.html#Diagram" class="link">Source</a></p><div class="doc"><p>The default sort of diagram is one where querying at a point
   simply tells you whether the diagram contains that point or not.
   Transforming a default diagram into one with a more interesting
   query can be done via the <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a></code> instance of <code><code><a href="Diagrams-Core.html#t:QDiagram">QDiagram</a></code> b</code> or
   the <code><a href="Diagrams-Core.html#v:value">value</a></code> function.
</p></div></div><div class="top"><p class="src"><a name="v:prims" class="def">prims</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; [(<a href="Diagrams-Core.html#t:Prim">Prim</a> b v, (<a href="Data-Monoid-Split.html#t:Split">Split</a> (<a href="Diagrams-Core.html#t:Transformation">Transformation</a> v), <a href="Diagrams-Core.html#t:Style">Style</a> v))]<a href="src/Diagrams-Core-Types.html#prims" class="link">Source</a></p><div class="doc"><p>Extract a list of primitives from a diagram, together with their
   associated transformations and styles.
</p></div></div><div class="top"><p class="src"><a name="v:envelope" class="def">envelope</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v<a href="src/Diagrams-Core-Types.html#envelope" class="link">Source</a></p><div class="doc"><p>Get the envelope of a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:trace" class="def">trace</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v<a href="src/Diagrams-Core-Types.html#trace" class="link">Source</a></p><div class="doc"><p>Get the trace of a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:subMap" class="def">subMap</a> ::  <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m<a href="src/Diagrams-Core-Types.html#subMap" class="link">Source</a></p><div class="doc"><p>Get the subdiagram map (<em>i.e.</em> an association from names to
   subdiagrams) of a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:names" class="def">names</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; [(<a href="Diagrams-Core.html#t:Name">Name</a>, [<a href="Diagrams-Core.html#t:Point">Point</a> v])]<a href="src/Diagrams-Core-Types.html#names" class="link">Source</a></p><div class="doc"><p>Get a list of names of subdiagrams and their locations.
</p></div></div><div class="top"><p class="src"><a name="v:query" class="def">query</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Query">Query</a> v m<a href="src/Diagrams-Core-Types.html#query" class="link">Source</a></p><div class="doc"><p>Get the query function associated with a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:sample" class="def">sample</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; m<a href="src/Diagrams-Core-Types.html#sample" class="link">Source</a></p><div class="doc"><p>Sample a diagram's query function at a given point.
</p></div></div><div class="top"><p class="src"><a name="v:value" class="def">value</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a> -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#value" class="link">Source</a></p><div class="doc"><p>Set the query value for <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></code> points in a diagram (<em>i.e.</em> points
   &quot;inside&quot; the diagram); <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></code> points will be set to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#v:mempty">mempty</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:resetValue" class="def">resetValue</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a><a href="src/Diagrams-Core-Types.html#resetValue" class="link">Source</a></p><div class="doc"><p>Reset the query values of a diagram to <code>True</code>/<code>False</code>: any values
   equal to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#v:mempty">mempty</a></code> are set to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></code>; any other values are set to
   <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:True">True</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:clearValue" class="def">clearValue</a> ::  <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Any">Any</a><a href="src/Diagrams-Core-Types.html#clearValue" class="link">Source</a></p><div class="doc"><p>Set all the query values of a diagram to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Bool.html#v:False">False</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:nameSub" class="def">nameSub</a> :: (<a href="Diagrams-Core.html#t:IsName">IsName</a> n, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m) -&gt; n -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#nameSub" class="link">Source</a></p><div class="doc"><p>Attach an atomic name to a certain subdiagram, computed from the
   given diagram.
</p></div></div><div class="top"><p class="src"><a name="v:withName" class="def">withName</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> n =&gt; n -&gt; (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#withName" class="link">Source</a></p><div class="doc"><p>Given a name and a diagram transformation indexed by a
   subdiagram, perform the transformation using the most recent
   subdiagram associated with (some qualification of) the name,
   or perform the identity transformation if the name does not exist.
</p></div></div><div class="top"><p class="src"><a name="v:withNameAll" class="def">withNameAll</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> n =&gt; n -&gt; ([<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m] -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#withNameAll" class="link">Source</a></p><div class="doc"><p>Given a name and a diagram transformation indexed by a list of
   subdiagrams, perform the transformation using the
   collection of all such subdiagrams associated with (some
   qualification of) the given name.
</p></div></div><div class="top"><p class="src"><a name="v:withNames" class="def">withNames</a> :: <a href="Diagrams-Core.html#t:IsName">IsName</a> n =&gt; [n] -&gt; ([<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m] -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#withNames" class="link">Source</a></p><div class="doc"><p>Given a list of names and a diagram transformation indexed by a
   list of subdiagrams, perform the transformation using the
   list of most recent subdiagrams associated with (some qualification
   of) each name.  Do nothing (the identity transformation) if any
   of the names do not exist.
</p></div></div><div class="top"><p class="src"><a name="v:localize" class="def">localize</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#localize" class="link">Source</a></p><div class="doc"><p>&quot;Localize&quot; a diagram by hiding all the names, so they are no
   longer visible to the outside.
</p></div></div><div class="top"><p class="src"><a name="v:freeze" class="def">freeze</a> :: <span class="keyword">forall</span> v b m. (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#freeze" class="link">Source</a></p><div class="doc"><p>By default, diagram attributes are not affected by
   transformations.  This means, for example, that <code>lw 0.01 circle</code>
   and <code>scale 2 (lw 0.01 circle)</code> will be drawn with lines of the
   <em>same</em> width, and <code>scaleY 3 circle</code> will be an ellipse drawn with
   a uniform line.  Once a diagram is frozen, however,
   transformations do affect attributes, so, for example, <code>scale 2
   (freeze (lw 0.01 circle))</code> will be drawn with a line twice as
   thick as <code>lw 0.01 circle</code>, and <code>scaleY 3 (freeze circle)</code> will be
   drawn with a &quot;stretched&quot;, variable-width line.
</p><p>Another way of thinking about it is that pre-<code>freeze</code>, we are
   transforming the &quot;abstract idea&quot; of a diagram, and the
   transformed version is then drawn; when doing a <code>freeze</code>, we
   produce a concrete drawing of the diagram, and it is this visual
   representation itself which is acted upon by subsequent
   transformations.
</p></div></div><div class="top"><p class="src"><a name="v:setEnvelope" class="def">setEnvelope</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; <a href="Diagrams-Core.html#t:Envelope">Envelope</a> v -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#setEnvelope" class="link">Source</a></p><div class="doc"><p>Replace the envelope of a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:setTrace" class="def">setTrace</a> :: <span class="keyword">forall</span> b v m. (<a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#setTrace" class="link">Source</a></p><div class="doc"><p>Replace the trace of a diagram.
</p></div></div><div class="top"><p class="src"><a name="v:atop" class="def">atop</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#atop" class="link">Source</a></p><div class="doc"><p>A convenient synonym for <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#v:mappend">mappend</a></code> on diagrams, designed to be
   used infix (to help remember which diagram goes on top of which
   when combining them, namely, the first on top of the second).
</p></div></div><h2 id="g:19">Subdiagrams
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Subdiagram" class="def">Subdiagram</a> b v m <a href="src/Diagrams-Core-Types.html#Subdiagram" class="link">Source</a></p><div class="doc"><p>A <code>Subdiagram</code> represents a diagram embedded within the context
   of a larger diagram.  Essentially, it consists of a diagram
   paired with any accumulated information from the larger context
   (transformations, attributes, etc.).
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Subdiagram" class="def">Subdiagram</a> (<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Subdiagram" class="caption collapser" onclick="toggleSection('i:Subdiagram')">Instances</p><div id="section.i:Subdiagram" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core.html#t:Traced">Traced</a> (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core.html#t:Enveloped">Enveloped</a> (<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core.html#t:SubMap">SubMap</a> b v m) (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> <a href="Diagrams-Core.html#t:Name">Name</a> [<a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m])</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:mkSubdiagram" class="def">mkSubdiagram</a> ::  <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m<a href="src/Diagrams-Core-Types.html#mkSubdiagram" class="link">Source</a></p><div class="doc"><p>Turn a diagram into a subdiagram with no accumulated context.
</p></div></div><div class="top"><p class="src"><a name="v:getSub" class="def">getSub</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#getSub" class="link">Source</a></p><div class="doc"><p>Turn a subdiagram into a normal diagram, including the enclosing
   context.  Concretely, a subdiagram is a pair of (1) a diagram and
   (2) a &quot;context&quot; consisting of an extra transformation and
   attributes.  <code>getSub</code> simply applies the transformation and
   attributes to the diagram to get the corresponding &quot;top-level&quot;
   diagram.
</p></div></div><div class="top"><p class="src"><a name="v:rawSub" class="def">rawSub</a> ::  <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m<a href="src/Diagrams-Core-Types.html#rawSub" class="link">Source</a></p><div class="doc"><p>Extract the &quot;raw&quot; content of a subdiagram, by throwing away the
   context.
</p></div></div><div class="top"><p class="src"><a name="v:location" class="def">location</a> :: <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v<a href="src/Diagrams-Core-Types.html#location" class="link">Source</a></p><div class="doc"><p>Get the location of a subdiagram; that is, the location of its
   local origin <em>with respect to</em> the vector space of its parent
   diagram.  In other words, the point where its local origin
   &quot;ended up&quot;.
</p></div></div><div class="top"><p class="src"><a name="v:subPoint" class="def">subPoint</a> :: (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="Diagrams-Core.html#t:Point">Point</a> v -&gt; <a href="Diagrams-Core.html#t:Subdiagram">Subdiagram</a> b v m<a href="src/Diagrams-Core-Types.html#subPoint" class="link">Source</a></p><div class="doc"><p>Create a &quot;point subdiagram&quot;, that is, a <code>pointDiagram</code> (with no
   content and a point envelope) treated as a subdiagram with local
   origin at the given point.  Note this is not the same as
   <code>mkSubdiagram . pointDiagram</code>, which would result in a subdiagram
   with local origin at the parent origin, rather than at the given
   point.
</p></div></div><h1 id="g:20">Backends
</h1><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:Render">Render</a> b v)) =&gt; <a name="t:Backend" class="def">Backend</a> b v  <span class="keyword">where</span><a href="src/Diagrams-Core-Types.html#Backend" class="link">Source</a></p><div class="doc"><p>Abstract diagrams are rendered to particular formats by
   <em>backends</em>.  Each backend/vector space combination must be an
   instance of the <code><a href="Diagrams-Core.html#t:Backend">Backend</a></code> class. A minimal complete definition
   consists of the three associated types and implementations for
   <code><a href="Diagrams-Core.html#v:withStyle">withStyle</a></code> and <code><a href="Diagrams-Core.html#v:doRender">doRender</a></code>.
</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">data</span> <a name="t:Render" class="def">Render</a> b v :: *<a href="src/Diagrams-Core-Types.html#Render" class="link">Source</a></p><div class="doc"><p>The type of rendering operations used by this backend, which
   must be a monoid. For example, if <code>Render b v = M ()</code> for some
   monad <code>M</code>, a monoid instance can be made with <code>mempty = return
   ()</code> and <code>mappend = (&gt;&gt;)</code>.
</p></div><p class="src"><span class="keyword">type</span> <a name="t:Result" class="def">Result</a> b v :: *<a href="src/Diagrams-Core-Types.html#Result" class="link">Source</a></p><div class="doc"><p>The result of running/interpreting a rendering operation.
</p></div><p class="src"><span class="keyword">data</span> <a name="t:Options" class="def">Options</a> b v :: *<a href="src/Diagrams-Core-Types.html#Options" class="link">Source</a></p><div class="doc"><p>Backend-specific rendering options.
</p></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:withStyle" class="def">withStyle</a><a href="src/Diagrams-Core-Types.html#withStyle" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: b</td><td class="doc"><p>Backend token (needed only for type inference)
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core.html#t:Style">Style</a> v</td><td class="doc"><p>Style to use
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core.html#t:Transformation">Transformation</a> v</td><td class="doc"><p>Transformation to be applied to the style
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core.html#t:Render">Render</a> b v</td><td class="doc"><p>Rendering operation to run
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core.html#t:Render">Render</a> b v</td><td class="doc"><p>Rendering operation using the style locally
</p></td></tr></table></div><div class="doc"><p>Perform a rendering operation with a local style.
</p></div><p class="src"><a name="v:doRender" class="def">doRender</a><a href="src/Diagrams-Core-Types.html#doRender" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: b</td><td class="doc"><p>Backend token (needed only for type inference)
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core.html#t:Options">Options</a> b v</td><td class="doc"><p>Backend-specific collection of rendering options
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core.html#t:Render">Render</a> b v</td><td class="doc"><p>Rendering operation to perform
</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-Core.html#t:Result">Result</a> b v</td><td class="doc"><p>Output of the rendering operation
</p></td></tr></table></div><div class="doc"><p><code><a href="Diagrams-Core.html#v:doRender">doRender</a></code> is used to interpret rendering operations.
</p></div><p class="src"><a name="v:adjustDia" class="def">adjustDia</a> :: <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m =&gt; b -&gt; <a href="Diagrams-Core.html#t:Options">Options</a> b v -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; (<a href="Diagrams-Core.html#t:Options">Options</a> b v, <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m)<a href="src/Diagrams-Core-Types.html#adjustDia" class="link">Source</a></p><div class="doc"><p><code><a href="Diagrams-Core.html#v:adjustDia">adjustDia</a></code> allows the backend to make adjustments to the final
   diagram (e.g. to adjust the size based on the options) before
   rendering it.  It can also make adjustments to the options
   record, usually to fill in incompletely specified size
   information.  A default implementation is provided which makes
   no adjustments.  See the diagrams-lib package for other useful
   implementations.
</p></div><p class="src"><a name="v:renderDia" class="def">renderDia</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; b -&gt; <a href="Diagrams-Core.html#t:Options">Options</a> b v -&gt; <a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m -&gt; <a href="Diagrams-Core.html#t:Result">Result</a> b v<a href="src/Diagrams-Core-Types.html#renderDia" class="link">Source</a></p><div class="doc"><p>Render a diagram.  This has a default implementation in terms
   of <code><a href="Diagrams-Core.html#v:adjustDia">adjustDia</a></code>, <code><a href="Diagrams-Core.html#v:withStyle">withStyle</a></code>, <code><a href="Diagrams-Core.html#v:doRender">doRender</a></code>, and the <code><a href="Diagrams-Core.html#v:render">render</a></code>
   operation from the <code><a href="Diagrams-Core.html#t:Renderable">Renderable</a></code> class (first <code><a href="Diagrams-Core.html#v:adjustDia">adjustDia</a></code> is
   used, then <code><a href="Diagrams-Core.html#v:withStyle">withStyle</a></code> and <code><a href="Diagrams-Core.html#v:render">render</a></code> are used to render each
   primitive, the resulting operations are combined with
   <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#v:mconcat">mconcat</a></code>, and the final operation run with <code><a href="Diagrams-Core.html#v:doRender">doRender</a></code>) but
   backends may override it if desired.
</p></div></div><div class="subs instances"><p id="control.i:Backend" class="caption collapser" onclick="toggleSection('i:Backend')">Instances</p><div id="section.i:Backend" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Backend">Backend</a> <a href="Diagrams-Core.html#t:NullBackend">NullBackend</a> v</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="Diagrams-Core.html#t:Backend">Backend</a> b v =&gt; <a name="t:MultiBackend" class="def">MultiBackend</a> b v  <span class="keyword">where</span><a href="src/Diagrams-Core-Types.html#MultiBackend" class="link">Source</a></p><div class="doc"><p>A class for backends which support rendering multiple diagrams,
   e.g. to a multi-page pdf or something similar.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:renderDias" class="def">renderDias</a> :: (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:InnerSpace">InnerSpace</a> v, <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m) =&gt; b -&gt; <a href="Diagrams-Core.html#t:Options">Options</a> b v -&gt; [<a href="Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m] -&gt; <a href="Diagrams-Core.html#t:Result">Result</a> b v<a href="src/Diagrams-Core-Types.html#renderDias" class="link">Source</a></p><div class="doc"><p>Render multiple diagrams at once.
</p></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="Diagrams-Core.html#t:Transformable">Transformable</a> t =&gt; <a name="t:Renderable" class="def">Renderable</a> t b  <span class="keyword">where</span><a href="src/Diagrams-Core-Types.html#Renderable" class="link">Source</a></p><div class="doc"><p>The Renderable type class connects backends to primitives which
   they know how to render.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:render" class="def">render</a> :: b -&gt; t -&gt; <a href="Diagrams-Core.html#t:Render">Render</a> b (<a href="Diagrams-Core.html#t:V">V</a> t)<a href="src/Diagrams-Core-Types.html#render" class="link">Source</a></p><div class="doc"><p>Given a token representing the backend and a
   transformable object, render it in the appropriate rendering
   context.
</p></div></div><div class="subs instances"><p id="control.i:Renderable" class="caption collapser" onclick="toggleSection('i:Renderable')">Instances</p><div id="section.i:Renderable" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Renderable">Renderable</a> (<a href="Diagrams-Core.html#t:Prim">Prim</a> b v) b</td><td class="doc"><p>The <code><a href="Diagrams-Core.html#t:Renderable">Renderable</a></code> instance for <code><a href="Diagrams-Core.html#t:Prim">Prim</a></code> just pushes calls to
   <code><a href="Diagrams-Core.html#v:render">render</a></code> down through the <code><a href="Diagrams-Core.html#t:Prim">Prim</a></code> constructor.
</p></td></tr></table></div></div></div><h2 id="g:21">The null backend
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:NullBackend" class="def">NullBackend</a>  <a href="src/Diagrams-Core-Types.html#NullBackend" class="link">Source</a></p><div class="doc"><p>A null backend which does no actual rendering.  It is provided
   mainly for convenience in situations where you must give a
   diagram a concrete, monomorphic type, but don't actually care
   which one.  See <code><a href="Diagrams-Core.html#t:D">D</a></code> for more explanation and examples.
</p><p>It is courteous, when defining a new primitive <code>P</code>, to make an instance
</p><pre> instance Renderable P NullBackend where
   render _ _ = mempty
</pre><p>This ensures that the trick with <code><a href="Diagrams-Core.html#t:D">D</a></code> annotations can be used for
   diagrams containing your primitive.
</p></div><div class="subs instances"><p id="control.i:NullBackend" class="caption collapser" onclick="toggleSection('i:NullBackend')">Instances</p><div id="section.i:NullBackend" class="show"><table><tr><td class="src"><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core.html#t:Backend">Backend</a> <a href="Diagrams-Core.html#t:NullBackend">NullBackend</a> v</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core.html#t:Render">Render</a> <a href="Diagrams-Core.html#t:NullBackend">NullBackend</a> v)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:D" class="def">D</a> v = <a href="Diagrams-Core.html#t:Diagram">Diagram</a> <a href="Diagrams-Core.html#t:NullBackend">NullBackend</a> v<a href="src/Diagrams-Core-Types.html#D" class="link">Source</a></p><div class="doc"><p>The <code>D</code> type is provided for convenience in situations where you
   must give a diagram a concrete, monomorphic type, but don't care
   which one.  Such situations arise when you pass a diagram to a
   function which is polymorphic in its input but monomorphic in its
   output, such as <code>width</code>, <code>height</code>, <code>phantom</code>, or <code><a href="Diagrams-Core.html#v:names">names</a></code>.  Such
   functions compute some property of the diagram, or use it to
   accomplish some other purpose, but do not result in the diagram
   being rendered.  If the diagram does not have a monomorphic type,
   GHC complains that it cannot determine the diagram's type.
</p><p>For example, here is the error we get if we try to compute the
   width of an image (this example requires <code>diagrams-lib</code>):
</p><pre> ghci&gt; width (image &quot;foo.png&quot; 200 200)

 &lt;interactive&gt;:8:8:
     No instance for (Renderable Diagrams.TwoD.Image.Image b0)
       arising from a use of `image'
     Possible fix:
       add an instance declaration for
       (Renderable Diagrams.TwoD.Image.Image b0)
     In the first argument of `width', namely
       `(image &quot;foo.png&quot; 200 200)'
     In the expression: width (image &quot;foo.png&quot; 200 200)
     In an equation for `it': it = width (image &quot;foo.png&quot; 200 200)
</pre><p>GHC complains that there is no instance for <code>Renderable Image
   b0</code>; what is really going on is that it does not have enough
   information to decide what backend to use (hence the
   uninstantiated <code>b0</code>). This is annoying because <em>we</em> know that the
   choice of backend cannot possibly affect the width of the image
   (it's 200! it's right there in the code!); <em>but</em> there is no way
   for GHC to know that.
</p><p>The solution is to annotate the call to <code>image</code> with the type
   <code><code><a href="Diagrams-Core.html#t:D">D</a></code> <code>R2</code></code>, like so:
</p><pre> ghci&gt; width (image &quot;foo.png&quot; 200 200 :: D R2)
 200.00000000000006
</pre><p>(It turns out the width wasn't 200 after all...)
</p><p>As another example, here is the error we get if we try to compute
   the width of a radius-1 circle:
</p><pre> ghci&gt; width (circle 1)

 &lt;interactive&gt;:4:1:
     Couldn't match type `V a0' with `R2'
     In the expression: width (circle 1)
     In an equation for `it': it = width (circle 1)
</pre><p>There's even more ambiguity here.  Whereas <code>image</code> always returns
   a <code><a href="Diagrams-Core.html#t:Diagram">Diagram</a></code>, the <code>circle</code> function can produce any <code>PathLike</code>
   type, and the <code>width</code> function can consume any <code><a href="Diagrams-Core.html#t:Enveloped">Enveloped</a></code> type,
   so GHC has no idea what type to pick to go in the middle.
   However, the solution is the same:
</p><pre> ghci&gt; width (circle 1 :: D R2)
 1.9999999999999998
</pre></div></div><h1 id="g:22">Convenience classes
</h1><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-Basis.html#t:HasBasis">HasBasis</a> v, <a href="http://hackage.haskell.org/packages/archive/MemoTrie/0.6.1/doc/html/Data-MemoTrie.html#t:HasTrie">HasTrie</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-Basis.html#t:Basis">Basis</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v) =&gt; <a name="t:HasLinearMap" class="def">HasLinearMap</a> v <a href="src/Diagrams-Core-Transform.html#HasLinearMap" class="link">Source</a></p><div class="doc"><p><code><a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a></code> is a poor man's class constraint synonym, just to
   help shorten some of the ridiculously long constraint sets.
</p></div><div class="subs instances"><p id="control.i:HasLinearMap" class="caption collapser" onclick="toggleSection('i:HasLinearMap')">Instances</p><div id="section.i:HasLinearMap" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-Basis.html#t:HasBasis">HasBasis</a> v, <a href="http://hackage.haskell.org/packages/archive/MemoTrie/0.6.1/doc/html/Data-MemoTrie.html#t:HasTrie">HasTrie</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-Basis.html#t:Basis">Basis</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v) =&gt; <a href="Diagrams-Core.html#t:HasLinearMap">HasLinearMap</a> v</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> s, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> s, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> s, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AdditiveGroup.html#t:AdditiveGroup">AdditiveGroup</a> s) =&gt; <a name="t:OrderedField" class="def">OrderedField</a> s <a href="src/Diagrams-Core-Envelope.html#OrderedField" class="link">Source</a></p><div class="doc"><p>When dealing with envelopes we often want scalars to be an
   ordered field (i.e. support all four arithmetic operations and be
   totally ordered) so we introduce this class as a convenient
   shorthand.
</p></div><div class="subs instances"><p id="control.i:OrderedField" class="caption collapser" onclick="toggleSection('i:OrderedField')">Instances</p><div id="section.i:OrderedField" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Fractional">Fractional</a> s, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Floating">Floating</a> s, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> s, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-AdditiveGroup.html#t:AdditiveGroup">AdditiveGroup</a> s) =&gt; <a href="Diagrams-Core.html#t:OrderedField">OrderedField</a> s</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a name="t:Monoid-39-" class="def">Monoid'</a> m </p><div class="doc"><p>The <code>Monoid'</code> class is a synonym for things which are instances
   of both <code><a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a></code> and <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a></code>.  Ideally, the <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a></code> class
   itself will eventually include a <code><a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a></code> superclass and we
   can get rid of this.
</p></div><div class="subs instances"><p id="control.i:Monoid-39-" class="caption collapser" onclick="toggleSection('i:Monoid-39-')">Instances</p><div id="section.i:Monoid-39-" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="Diagrams-Core.html#t:Monoid-39-">Monoid'</a> m</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>