<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Diagrams.Backend.Cairo</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Diagrams-Backend-Cairo.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Diagrams-Backend-Cairo.html">Source</a></li><li><a href="http://www.haskell.org/haskellwiki/Diagrams/Comments/Diagrams.Backend.Cairo">User Comments</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">diagrams-cairo-0.7: Cairo backend for diagrams drawing EDSL</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Maintainer</th><td>diagrams-discuss@googlegroups.com</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Diagrams.Backend.Cairo</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Rendering
</a></li><li><a href="#g:2">Cairo-supported output formats
</a></li><li><a href="#g:3">Cairo-specific options
</a></li><li><a href="#g:4">Backend token
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A full-featured rendering backend for diagrams using the
 cairo rendering engine.
</p><p>To invoke the cairo backend, you have three options.
</p><ul><li> You can use the <a href="Diagrams-Backend-Cairo-CmdLine.html">Diagrams.Backend.Cairo.CmdLine</a> module to create
   standalone executables which output images when invoked.
</li><li> You can use the <code><a href="Diagrams-Backend-Cairo.html#v:renderCairo">renderCairo</a></code> function provided by this module,
   which gives you more flexible programmatic control over when and
   how images are output (making it easy to, for example, write a
   single program that outputs multiple images, or one that outputs
   images dynamically based on user input, and so on).
</li><li> Finally, for the most flexibility, you can directly
   use methods from the
   <code><a href="Diagrams-Core-Types.html#t:Backend">Backend</a></code> instance for <code>Cairo</code>.  In particular,
   <code><a href="Diagrams-Core-Types.html#t:renderDia">renderDia</a></code> has the generic type
</li></ul><pre> renderDia :: b -&gt; Options b v -&gt; QDiagram b v m -&gt; Result b v
</pre><p>(omitting a few type class constraints).  <code>b</code> represents the
 backend type, <code>v</code> the vector space, and <code>m</code> the type of monoidal
 query annotations on the diagram.  <code><a href="Diagrams-Core-Types.html#t:Options">Options</a></code> and <code><a href="Diagrams-Core-Types.html#t:Result">Result</a></code> are
 associated data and type families, respectively, which yield the
 type of option records and rendering results specific to any
 particular backend.  For <code>b ~ Cairo</code> and <code>v ~ R2</code>, we have
</p><pre> data family Options Cairo R2 = CairoOptions
          { cairoFileName     :: String     -- ^ The name of the file you want generated
          , cairoSizeSpec     :: SizeSpec2D -- ^ The requested size of the output
          , cairoOutputType   :: OutputType -- ^ the output format and associated options
          , cairoBypassAdjust :: Bool       -- ^ Should the 'adjustDia' step be bypassed during rendering?
          }
</pre><pre>
 type family Result Cairo R2 = (IO (), <code><a href="http://hackage.haskell.org/packages/archive/cairo/0.12.4/doc/html/Graphics-Rendering-Cairo.html#t:Render">Render</a></code> ())
</pre><p>So the type of <code><a href="Diagrams-Core-Types.html#v:renderDia">renderDia</a></code> resolves to
</p><pre>
 renderDia :: Cairo -&gt; Options Cairo R2 -&gt; QDiagram Cairo R2 m -&gt; (IO (), <code><a href="http://hackage.haskell.org/packages/archive/cairo/0.12.4/doc/html/Graphics-Rendering-Cairo.html#t:Render">Render</a></code> ())
</pre><p>which you could call like so:
</p><pre>
 renderDia Cairo (CairoOptions &quot;foo.png&quot; (Width 250) PNG False) (myDiagram :: Diagram Cairo R2)
</pre><p>This would return a pair; the first element is an <code>IO ()</code> action
 which will write out <code>foo.png</code> to disk, and the second is a cairo
 rendering action which can be used, for example, to directly draw
 to a Gtk window.  Note the type annotation on <code>myDiagram</code> which may
 be necessary to fix the type variable <code>m</code>; this example uses the
 type synonym <code>Diagram b v = QDiagram b v Any</code> to fix <code>m = Any</code>.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:renderCairo">renderCairo</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; <a href="Diagrams-TwoD-Size.html#t:SizeSpec2D">SizeSpec2D</a> -&gt; <a href="Diagrams-Core-Types.html#t:Diagram">Diagram</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><span class="keyword">data</span>  <a href="#t:OutputType">OutputType</a> <ul class="subs"><li>= <a href="#v:PNG">PNG</a>  </li><li>| <a href="#v:PS">PS</a>  </li><li>| <a href="#v:PDF">PDF</a>  </li><li>| <a href="#v:SVG">SVG</a>  </li><li>| <a href="#v:RenderOnly">RenderOnly</a>  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Cairo">Cairo</a>  = <a href="#v:Cairo">Cairo</a></li></ul></div><div id="interface"><h1 id="g:1">Rendering
</h1><div class="top"><p class="src"><a name="v:renderCairo" class="def">renderCairo</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; <a href="Diagrams-TwoD-Size.html#t:SizeSpec2D">SizeSpec2D</a> -&gt; <a href="Diagrams-Core-Types.html#t:Diagram">Diagram</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-IO.html#t:IO">IO</a> ()<a href="src/Diagrams-Backend-Cairo.html#renderCairo" class="link">Source</a></p><div class="doc"><p>Render a diagram using the cairo backend, writing to the given
   output file and using the requested size.  The output type (PNG,
   PS, PDF, or SVG) is determined automatically from the output file
   extension.
</p><p>This function is provided as a convenience; if you need more
   flexibility than it provides, you can call <code><a href="Diagrams-Core-Types.html#v:renderDia">renderDia</a></code> directly,
   as described above.
</p></div></div><h1 id="g:2">Cairo-supported output formats
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:OutputType" class="def">OutputType</a>  <a href="src/Diagrams-Backend-Cairo-Internal.html#OutputType" class="link">Source</a></p><div class="doc"><p>Output types supported by cairo, including four different file
   types (PNG, PS, PDF, SVG).  If you want to output directly to GTK
   windows, see the <code>diagrams-gtk</code> package.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:PNG" class="def">PNG</a></td><td class="doc"><p>Portable Network Graphics output.
</p></td></tr><tr><td class="src"><a name="v:PS" class="def">PS</a></td><td class="doc"><p>PostScript output
</p></td></tr><tr><td class="src"><a name="v:PDF" class="def">PDF</a></td><td class="doc"><p>Portable Document Format output.
</p></td></tr><tr><td class="src"><a name="v:SVG" class="def">SVG</a></td><td class="doc"><p>Scalable Vector Graphics output.
</p></td></tr><tr><td class="src"><a name="v:RenderOnly" class="def">RenderOnly</a></td><td class="doc"><p>Don't output any file; the returned <code>IO ()</code>
   action will do nothing, but the <code>Render ()</code>
   action can be used (<em>e.g.</em> to draw to a Gtk
   window; see the <code>diagrams-gtk</code> package).
</p></td></tr></table></div><div class="subs instances"><p id="control.i:OutputType" class="caption collapser" onclick="toggleSection('i:OutputType')">Instances</p><div id="section.i:OutputType" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Bounded">Bounded</a> <a href="Diagrams-Backend-Cairo.html#t:OutputType">OutputType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Enum">Enum</a> <a href="Diagrams-Backend-Cairo.html#t:OutputType">OutputType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Diagrams-Backend-Cairo.html#t:OutputType">OutputType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Diagrams-Backend-Cairo.html#t:OutputType">OutputType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Read.html#t:Read">Read</a> <a href="Diagrams-Backend-Cairo.html#t:OutputType">OutputType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> <a href="Diagrams-Backend-Cairo.html#t:OutputType">OutputType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> <a href="Diagrams-Backend-Cairo.html#t:OutputType">OutputType</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:3">Cairo-specific options
</h1><div class="doc"><p>Unfortunately, Haddock does not yet support documentation for
 associated data families, so we must just provide it manually.
 This module defines
</p><pre> data family Options Cairo R2 = CairoOptions
           { cairoFileName   :: String     -- ^ The name of the file you want generated
           , cairoSizeSpec   :: SizeSpec2D -- ^ The requested size of the output
           , cairoOutputType :: OutputType -- ^ the output format and associated options
           }
</pre><p>See the documentation at the top of <a href="Diagrams-Backend-Cairo.html">Diagrams.Backend.Cairo</a> for
 information on how to make use of this.
</p><p><em>Important note</em>: a bug in GHC 7.0.x and 7.4.1 prevents
 re-exporting this data family.  (Strangely, this bug seems to be
 present in 7.0 and 7.4 but not 7.2.) To bring CairoOptions into
 scope when using GHC 7.0.x or 7.4 you must import
 <a href="Diagrams-Backend-Cairo-Internal.html">Diagrams.Backend.Cairo.Internal</a>.
</p></div><h1 id="g:4">Backend token
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Cairo" class="def">Cairo</a>  <a href="src/Diagrams-Backend-Cairo-Internal.html#Cairo" class="link">Source</a></p><div class="doc"><p>This data declaration is simply used as a token to distinguish
   the cairo backend: (1) when calling functions where the type
   inference engine would otherwise have no way to know which
   backend you wanted to use, and (2) as an argument to the
   <code><a href="Diagrams-Core-Types.html#t:Backend">Backend</a></code> and <code><a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a></code> type classes.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Cairo" class="def">Cairo</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Cairo" class="caption collapser" onclick="toggleSection('i:Cairo')">Instances</p><div id="section.i:Cairo" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Read.html#t:Read">Read</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Types.html#t:Backend">Backend</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> <a href="Diagrams-TwoD-Text.html#t:Text">Text</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> <a href="Diagrams-TwoD-Image.html#t:Image">Image</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Path.html#t:Path">Path</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a>) <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Trail.html#t:Trail">Trail</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a>) <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Diagrams-Core-Types.html#t:Options">Options</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core-Types.html#t:Render">Render</a> <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Segment.html#t:Segment">Segment</a> <a href="Diagrams-Segment.html#t:Closed">Closed</a> <a href="Diagrams-TwoD-Types.html#t:R2">R2</a>) <a href="Diagrams-Backend-Cairo.html#t:Cairo">Cairo</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>