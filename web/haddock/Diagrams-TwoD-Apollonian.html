<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Diagrams.TwoD.Apollonian</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Diagrams-TwoD-Apollonian.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Diagrams-TwoD-Apollonian.html">Source</a></li><li><a href="http://www.haskell.org/haskellwiki/Diagrams/Comments/Diagrams.TwoD.Apollonian">User Comments</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">diagrams-contrib-1.3.0: Collection of user contributions to diagrams EDSL</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) 2011 Brent Yorgey</td></tr><tr><th>License</th><td>BSD-style (see LICENSE)</td></tr><tr><th>Maintainer</th><td>byorgey@cis.upenn.edu</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Diagrams.TwoD.Apollonian</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Circles</a></li><li><a href="#g:2">Descartes' Theorem</a></li><li><a href="#g:3">Apollonian gasket generation</a></li><li><a href="#g:4">Diagram generation</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Generation of Apollonian gaskets.  Any three mutually tangent
 circles uniquely determine exactly two others which are mutually
 tangent to all three.  This process can be repeated, generating a
 fractal circle packing.</p><p>See J. Lagarias, C. Mallows, and A. Wilks, &quot;Beyond the Descartes
 circle theorem&quot;, <em>Amer. Math. Monthly</em> 109 (2002), 338--361.
 <a href="http://arxiv.org/abs/math/0101066">http://arxiv.org/abs/math/0101066</a>.</p><p>A few examples:</p><pre>import Diagrams.TwoD.Apollonian
apollonian1 = apollonianGasket 0.01 2 2 2</pre><p><img src="diagrams/src_Diagrams_TwoD_Apollonian_apollonian1.svg#diagram=apollonian1&amp;width=400" /></p><pre>import Diagrams.TwoD.Apollonian
apollonian2 = apollonianGasket 0.01 2 3 3</pre><p><img src="diagrams/src_Diagrams_TwoD_Apollonian_apollonian2.svg#diagram=apollonian2&amp;width=400" /></p><pre>import Diagrams.TwoD.Apollonian
apollonian3 = apollonianGasket 0.01 2 4 7</pre><p><img src="diagrams/src_Diagrams_TwoD_Apollonian_apollonian3.svg#diagram=apollonian3&amp;width=400" /></p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Circle">Circle</a> n = <a href="#v:Circle">Circle</a> {<ul class="subs"><li><a href="#v:bend">bend</a> :: n</li><li><a href="#v:cb">cb</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Data-Complex.html#t:Complex">Complex</a> n</li></ul>}</li><li class="src short"><a href="#v:mkCircle">mkCircle</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Fractional">Fractional</a> n =&gt; n -&gt; <a href="Diagrams-TwoD-Types.html#t:P2">P2</a> n -&gt; <a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n</li><li class="src short"><a href="#v:center">center</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Fractional">Fractional</a> n =&gt; <a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n -&gt; <a href="Diagrams-TwoD-Types.html#t:P2">P2</a> n</li><li class="src short"><a href="#v:radius">radius</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Fractional">Fractional</a> n =&gt; <a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n -&gt; n</li><li class="src short"><a href="#v:descartes">descartes</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Floating">Floating</a> n =&gt; [n] -&gt; [n]</li><li class="src short"><a href="#v:other">other</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Num">Num</a> n =&gt; [n] -&gt; n -&gt; n</li><li class="src short"><a href="#v:initialConfig">initialConfig</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:RealFloat">RealFloat</a> n =&gt; n -&gt; n -&gt; n -&gt; [<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n]</li><li class="src short"><a href="#v:apollonian">apollonian</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:RealFloat">RealFloat</a> n =&gt; n -&gt; [<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n] -&gt; [<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n]</li><li class="src short"><a href="#v:drawCircle">drawCircle</a> :: (<a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Path.html#t:Path">Path</a> <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n) b, <a href="Diagrams-Core-Types.html#t:TypeableFloat">TypeableFloat</a> n) =&gt; n -&gt; <a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Data-Monoid.html#t:Any">Any</a></li><li class="src short"><a href="#v:drawGasket">drawGasket</a> :: (<a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Path.html#t:Path">Path</a> <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n) b, <a href="Diagrams-Core-Types.html#t:TypeableFloat">TypeableFloat</a> n) =&gt; [<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n] -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Data-Monoid.html#t:Any">Any</a></li><li class="src short"><a href="#v:apollonianGasket">apollonianGasket</a> :: (<a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Path.html#t:Path">Path</a> <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n) b, <a href="Diagrams-Core-Types.html#t:TypeableFloat">TypeableFloat</a> n) =&gt; n -&gt; n -&gt; n -&gt; n -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Data-Monoid.html#t:Any">Any</a></li></ul></div><div id="interface"><h1 id="g:1">Circles</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Circle" class="def">Circle</a> n <a href="src/Diagrams-TwoD-Apollonian.html#line-75" class="link">Source</a></p><div class="doc"><p>Representation for circles that lets us quickly compute an
   Apollonian gasket.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Circle" class="def">Circle</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:bend" class="def">bend</a> :: n</dt><dd class="doc"><p>The bend is the reciprocal of signed
   radius: a negative radius means the
   outside and inside of the circle are
   switched.  The bends of any four mutually
   tangent circles satisfy Descartes'
   Theorem.</p></dd><dt class="src"><a name="v:cb" class="def">cb</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Data-Complex.html#t:Complex">Complex</a> n</dt><dd class="doc"><p><em>Product</em> of bend and center represented
   as a complex number.  Amazingly, these
   products also satisfy the equation of
   Descartes' Theorem.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Circle" class="caption collapser" onclick="toggleSection('i:Circle')">Instances</p><div id="section.i:Circle" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Data-Eq.html#t:Eq">Eq</a> n =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:RealFloat">RealFloat</a> n =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Floating">Floating</a> (<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n)</td><td class="doc"><p>The <code>Num</code>, <code>Fractional</code>, and <code>Floating</code> instances for <code>Circle</code>
   (all simply lifted elementwise over <code>Circle</code>'s fields) let us use
   Descartes' Theorem directly on circles.</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:RealFloat">RealFloat</a> n =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Fractional">Fractional</a> (<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:RealFloat">RealFloat</a> n =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Num">Num</a> (<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Text-Show.html#t:Show">Show</a> n =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:mkCircle" class="def">mkCircle</a> <a href="src/Diagrams-TwoD-Apollonian.html#line-91" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Fractional">Fractional</a> n</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; n</td><td class="doc"><p>signed radius</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-TwoD-Types.html#t:P2">P2</a> n</td><td class="doc"><p>center</p></td></tr><tr><td class="src">-&gt; <a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Create a <code>Circle</code> given a signed radius and a location for its center.</p></div></div><div class="top"><p class="src"><a name="v:center" class="def">center</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Fractional">Fractional</a> n =&gt; <a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n -&gt; <a href="Diagrams-TwoD-Types.html#t:P2">P2</a> n <a href="src/Diagrams-TwoD-Apollonian.html#line-99" class="link">Source</a></p><div class="doc"><p>Get the center of a circle.</p></div></div><div class="top"><p class="src"><a name="v:radius" class="def">radius</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Fractional">Fractional</a> n =&gt; <a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n -&gt; n <a href="src/Diagrams-TwoD-Apollonian.html#line-103" class="link">Source</a></p><div class="doc"><p>Get the (unsigned) radius of a circle.</p></div></div><h1 id="g:2">Descartes' Theorem</h1><div class="top"><p class="src"><a name="v:descartes" class="def">descartes</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Floating">Floating</a> n =&gt; [n] -&gt; [n] <a href="src/Diagrams-TwoD-Apollonian.html#line-151" class="link">Source</a></p><div class="doc"><p>Descartes' Theorem states that if <code>b1</code>, <code>b2</code>, <code>b3</code> and <code>b4</code> are
   the bends of four mutually tangent circles, then</p><pre>    b1^2 + b2^2 + b3^2 + b4^2 = 1/2 * (b1 + b2 + b3 + b4)^2.
  </pre><p>Surprisingly, if we replace each of the <code>bi</code> with the <em>product</em>
   of <code>bi</code> and the center of the corresponding circle (represented
   as a complex number), the equation continues to hold! (See the
   paper referenced at the top of the module.)</p><p><code>descartes [b1,b2,b3]</code> solves for <code>b4</code>, returning both solutions.
   Notably, <code>descartes</code> works for any instance of <code>Floating</code>, which
   includes both <code>Double</code> (for bends), <code>Complex Double</code> (for
   bend/center product), and <code>Circle</code> (for both at once).</p></div></div><div class="top"><p class="src"><a name="v:other" class="def">other</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:Num">Num</a> n =&gt; [n] -&gt; n -&gt; n <a href="src/Diagrams-TwoD-Apollonian.html#line-170" class="link">Source</a></p><div class="doc"><p>If we have <em>four</em> mutually tangent circles we can choose one of
   them to replace; the remaining three determine exactly one other
   circle which is mutually tangent.  However, in this situation
   there is no need to apply <code><a href="Diagrams-TwoD-Apollonian.html#v:descartes">descartes</a></code> again, since the two
   solutions <code>b4</code> and <code>b4'</code> satisfy</p><pre>    b4 + b4' = 2 * (b1 + b2 + b3)
  </pre><p>Hence, to replace <code>b4</code> with its dual, we need only sum the other
   three, multiply by two, and subtract <code>b4</code>.  Again, this works for
   bends as well as bend/center products.</p></div></div><div class="top"><p class="src"><a name="v:initialConfig" class="def">initialConfig</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:RealFloat">RealFloat</a> n =&gt; n -&gt; n -&gt; n -&gt; [<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n] <a href="src/Diagrams-TwoD-Apollonian.html#line-175" class="link">Source</a></p><div class="doc"><p>Generate an initial configuration of four mutually tangent
   circles, given just the signed bends of three of them.</p></div></div><h1 id="g:3">Apollonian gasket generation</h1><div class="top"><p class="src"><a name="v:apollonian" class="def">apollonian</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:RealFloat">RealFloat</a> n =&gt; n -&gt; [<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n] -&gt; [<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n] <a href="src/Diagrams-TwoD-Apollonian.html#line-198" class="link">Source</a></p><div class="doc"><p>Given a threshold radius and a list of <em>four</em> mutually tangent
   circles, generate the Apollonian gasket containing those circles.
   Stop the recursion when encountering a circle with an (unsigned)
   radius smaller than the threshold.</p></div></div><h1 id="g:4">Diagram generation</h1><div class="top"><p class="src"><a name="v:drawCircle" class="def">drawCircle</a> :: (<a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Path.html#t:Path">Path</a> <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n) b, <a href="Diagrams-Core-Types.html#t:TypeableFloat">TypeableFloat</a> n) =&gt; n -&gt; <a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Data-Monoid.html#t:Any">Any</a> <a href="src/Diagrams-TwoD-Apollonian.html#line-220" class="link">Source</a></p><div class="doc"><p>Draw a circle.</p></div></div><div class="top"><p class="src"><a name="v:drawGasket" class="def">drawGasket</a> :: (<a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Path.html#t:Path">Path</a> <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n) b, <a href="Diagrams-Core-Types.html#t:TypeableFloat">TypeableFloat</a> n) =&gt; [<a href="Diagrams-TwoD-Apollonian.html#t:Circle">Circle</a> n] -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Data-Monoid.html#t:Any">Any</a> <a href="src/Diagrams-TwoD-Apollonian.html#line-227" class="link">Source</a></p><div class="doc"><p>Draw a generated gasket, using a line width 0.003 times the
   radius of the largest circle.</p></div></div><div class="top"><p class="src"><a name="v:apollonianGasket" class="def">apollonianGasket</a> :: (<a href="Diagrams-Core-Types.html#t:Renderable">Renderable</a> (<a href="Diagrams-Path.html#t:Path">Path</a> <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n) b, <a href="Diagrams-Core-Types.html#t:TypeableFloat">TypeableFloat</a> n) =&gt; n -&gt; n -&gt; n -&gt; n -&gt; <a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b <a href="Diagrams-TwoD-Types.html#t:V2">V2</a> n <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Data-Monoid.html#t:Any">Any</a> <a href="src/Diagrams-TwoD-Apollonian.html#line-235" class="link">Source</a></p><div class="doc"><p>Draw an Apollonian gasket: the first argument is the threshold;
   the recursion will stop upon reaching circles with radii less than
   it. The next three arguments are bends of three circles.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>