<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Diagrams.Core.Trace</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Diagrams-Core-Trace.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Diagrams-Core-Trace.html">Source</a></li><li><a href="http://www.haskell.org/haskellwiki/Diagrams/Comments/Diagrams.Core.Trace">User Comments</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">diagrams-core-0.7: Core libraries for diagrams EDSL</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Maintainer</th><td>diagrams-discuss@googlegroups.com</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Diagrams.Core.Trace</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Traces
</a></li><li><a href="#g:2">Traced class
</a></li><li><a href="#g:3">Computing with traces
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p><code>diagrams-core</code> defines the core library of primitives
 forming the basis of an embedded domain-specific language for
 describing and rendering diagrams.
</p><p>The <code>Trace</code> module defines a data type and type class for
 &quot;traces&quot;, aka functional boundaries, essentially corresponding to
 embedding a raytracer with each diagram.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">newtype</span>  <a href="#t:Trace">Trace</a> v = <a href="#v:Trace">Trace</a> {<ul class="subs"><li><a href="#v:appTrace">appTrace</a> :: <a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)</li></ul>}</li><li class="src short"><a href="#v:inTrace">inTrace</a> ::  ((<a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v</li><li class="src short"><a href="#v:mkTrace">mkTrace</a> ::  (<a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v</li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a)), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a)) =&gt; <a href="#t:Traced">Traced</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:getTrace">getTrace</a> :: a -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a)</li></ul></li><li class="src short"><a href="#v:traceV">traceV</a> :: <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core-V.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a)</li><li class="src short"><a href="#v:traceP">traceP</a> :: <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core-V.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a))</li><li class="src short"><a href="#v:maxTraceV">maxTraceV</a> :: <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core-V.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a)</li><li class="src short"><a href="#v:maxTraceP">maxTraceP</a> :: <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core-V.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a))</li></ul></div><div id="interface"><h1 id="g:1">Traces
</h1><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:Trace" class="def">Trace</a> v <a href="src/Diagrams-Core-Trace.html#Trace" class="link">Source</a></p><div class="doc"><p>Every diagram comes equipped with a <em>trace</em>.  Intuitively, the
   trace for a diagram is like a raytracer: given a line
   (represented as a base point and a direction), the trace computes
   the distance from the base point along the line to the first
   intersection with the diagram.  The distance can be negative if
   the intersection is in the opposite direction from the base
   point, or infinite if the ray never intersects the diagram.
   Note: to obtain the distance to the <em>furthest</em> intersection
   instead of the <em>closest</em>, just negate the direction vector and
   then negate the result.
</p><p>Note that the output should actually be interpreted not as an
   absolute distance, but as a multiplier relative to the input
   vector.  That is, if the input vector is <code>v</code> and the returned
   scalar is <code>s</code>, the distance from the base point to the
   intersection is given by <code>s * magnitude v</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Trace" class="def">Trace</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:appTrace" class="def">appTrace</a> :: <a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Trace" class="caption collapser" onclick="toggleSection('i:Trace')">Instances</p><div id="section.i:Trace" class="show"><table><tr><td class="src"><a href="Data-Monoid-Action.html#t:Action">Action</a> <a href="Diagrams-Core-Names.html#t:Name">Name</a> (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v) =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v =&gt; <a href="Diagrams-Core-HasOrigin.html#t:HasOrigin">HasOrigin</a> (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v =&gt; <a href="Diagrams-Core-Transform.html#t:Transformable">Transformable</a> (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v) =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m) (<a href="Data-Tree-DUAL-Internal.html#t:DUALTree">DUALTree</a> (<a href="Diagrams-Core-Types.html#t:DownAnnots">DownAnnots</a> v) (<a href="Diagrams-Core-Types.html#t:UpAnnots">UpAnnots</a> b v m) () (<a href="Diagrams-Core-Types.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:inTrace" class="def">inTrace</a> ::  ((<a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v<a href="src/Diagrams-Core-Trace.html#inTrace" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:mkTrace" class="def">mkTrace</a> ::  (<a href="Diagrams-Core-Points.html#t:Point">Point</a> v -&gt; v -&gt; <a href="Data-Monoid-Inf.html#t:PosInf">PosInf</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v<a href="src/Diagrams-Core-Trace.html#mkTrace" class="link">Source</a></p></div><h1 id="g:2">Traced class
</h1><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a)), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a)) =&gt; <a name="t:Traced" class="def">Traced</a> a  <span class="keyword">where</span><a href="src/Diagrams-Core-Trace.html#Traced" class="link">Source</a></p><div class="doc"><p><code>Traced</code> abstracts over things which have a trace.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:getTrace" class="def">getTrace</a> :: a -&gt; <a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a)<a href="src/Diagrams-Core-Trace.html#getTrace" class="link">Source</a></p><div class="doc"><p>Compute the trace of an object.
</p></div></div><div class="subs instances"><p id="control.i:Traced" class="caption collapser" onclick="toggleSection('i:Traced')">Instances</p><div id="section.i:Traced" class="show"><table><tr><td class="src"><a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> b =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> [b]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> b =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Set.html#t:Set">Set</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v) =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (<a href="Diagrams-Core-Points.html#t:Point">Point</a> v)</td><td class="doc"><p>The trace of a single point is the empty trace, <em>i.e.</em> the one
   which returns positive infinity for every query.  Arguably it
   should return a finite distance for vectors aimed directly at the
   given point and infinity for everything else, but due to
   floating-point inaccuracy this is problematic.  Note that the
   envelope for a single point is <em>not</em> the empty envelope (see
   <a href="Diagrams-Core-Envelope.html">Diagrams.Core.Envelope</a>).
</p></td></tr><tr><td class="src"><a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> t =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (<a href="Diagrams-Core-Transform.html#t:TransInv">TransInv</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v) =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (<a href="Diagrams-Core-Trace.html#t:Trace">Trace</a> v)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> a, <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> b, ~ * (<a href="Diagrams-Core-V.html#t:V">V</a> a) (<a href="Diagrams-Core-V.html#t:V">V</a> b)) =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> b =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (<a href="http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html#t:Map">Map</a> k b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v), <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v) =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (<a href="Diagrams-Core-Types.html#t:Subdiagram">Subdiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Diagrams-Core-Transform.html#t:HasLinearMap">HasLinearMap</a> v, <a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace">VectorSpace</a> v, <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:Scalar">Scalar</a> v)) =&gt; <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> (<a href="Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v m)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:3">Computing with traces
</h1><div class="top"><p class="src"><a name="v:traceV" class="def">traceV</a> :: <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core-V.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a)<a href="src/Diagrams-Core-Trace.html#traceV" class="link">Source</a></p><div class="doc"><p>Compute the vector from the given point to the boundary of the
   given object in the given direction, or <code>Nothing</code> if there is no
   intersection.
</p></div></div><div class="top"><p class="src"><a name="v:traceP" class="def">traceP</a> :: <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core-V.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a))<a href="src/Diagrams-Core-Trace.html#traceP" class="link">Source</a></p><div class="doc"><p>Given a base point and direction, compute the closest point on
   the boundary of the given object, or <code>Nothing</code> if there is no
   intersection in the given direction.
</p></div></div><div class="top"><p class="src"><a name="v:maxTraceV" class="def">maxTraceV</a> :: <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core-V.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a)<a href="src/Diagrams-Core-Trace.html#maxTraceV" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Diagrams-Core-Trace.html#v:traceV">traceV</a></code>, but computes a vector to the *furthest* point on
   the boundary instead of the closest.
</p></div></div><div class="top"><p class="src"><a name="v:maxTraceP" class="def">maxTraceP</a> :: <a href="Diagrams-Core-Trace.html#t:Traced">Traced</a> a =&gt; <a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a) -&gt; <a href="Diagrams-Core-V.html#t:V">V</a> a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Diagrams-Core-Points.html#t:Point">Point</a> (<a href="Diagrams-Core-V.html#t:V">V</a> a))<a href="src/Diagrams-Core-Trace.html#maxTraceP" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Diagrams-Core-Trace.html#v:traceP">traceP</a></code>, but computes the *furthest* point on the boundary
   instead of the closest.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>